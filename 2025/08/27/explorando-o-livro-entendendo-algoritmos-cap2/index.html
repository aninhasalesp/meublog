<!DOCTYPE html>
<html lang="en">
<head>
        <title>Explorando o livro ‚ÄúEntendendo Algoritmos‚Äù,¬†cap.2</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="@aninhasalesp Atom Feed" />
</head>

<body id="index" class="home" style="margin: auto;">
        <header id="banner" class="body">
                <h1><a href="/">@aninhasalesp </a></h1>
                <nav>
                    <!-- BOT√ÉO HAMB√öRGUER FORA DA UL -->
                    <button class="menu-toggle" onclick="toggleMenu()">
                        <div class="hamburger">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </button>
                    <!-- S√ì UMA UL COM ID="menu" -->
                    <ul id="menu">
                    <li ><a href="/pages/contato.html">Contato</a></li>
                    <li ><a href="/pages/sugestoes-de-leitura.html">Sugest√µes de&nbsp;leitura</a></li>
                    <li ><a href="/pages/quem-sou-eu.html">Quem sou eu?&nbsp;üåøüå∏</a></li>
                <li><a href="/">Posts</a></li>
                    <li>
                        <a href="/feeds/all.atom.xml" title="Assinar RSS">
                            <img src="/images/rss-icon.png" alt="RSS" style="width:20px;height:20px;vertical-align:middle;">
                        </a>
                    </li>

                </ul>
                </nav>
        </header><!-- /#banner -->

<div style="display: flex; flex-direction: column;">
  <section id="content" class="body">
    <article>
      <header>
        <h1 class="entry-title">
          <a href="2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/" rel="bookmark">
            Explorando o livro &#8220;Entendendo Algoritmos&#8221;,&nbsp;cap.2
          </a>
        </h1>       </header>

      <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-08-27T00:00:00-03:00">
                qua 27 agosto 2025
        </abbr>

        <!-- <address class="vcard author">
                By <a class="url fn" href="/author/ana-paula-sales.html">Ana Paula Sales</a>
        </address> -->
<!-- <p>In <a href="/category/entendendo-algoritmos.html">Entendendo algoritmos</a>. </p> -->
</p></footer><!-- /.post-info --><!-- /.post-info -->
        <p>Segundo cap√≠tulo da s√©rie de estudos sobre o livro <a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf">Entendendo Algoritmos</a> de Aditya Y.&nbsp;Bhargava.</p>
<p>Espero que voc√™s tenham gostado da forma como estruturei o <a href="https://anapaula.org/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/">primeiro cap√≠tulo</a>, seguirei naquela mesma linha de racioc√≠nio e explica√ß√£o. Se voc√™ tiver alguma sugest√£o de exerc√≠cio ou melhoria na explica√ß√£o, me conta aqui que eu ficarei feliz em receber esse feedback&nbsp;ü´Çüíï</p>
<hr>
<p>No cap√≠tulo 2, o autor aprofunda dois conceitos fundamentais: <strong>estruturas de dados</strong> (como arrays e listas) e a <strong>efici√™ncia dos algoritmos</strong> (nota√ß√£o Big O). Para ilustrar isso, ele apresenta o algoritmo de <strong>ordena√ß√£o por sele√ß√£o</strong>.</p>
<h1>Arrays e&nbsp;Listas</h1>
<p>Antes de falar em ordena√ß√£o, √© importante entender como os dados podem ser armazenados na mem√≥ria.&nbsp;üëÄ</p>
<p>O autor traz uma analogia que faz o entendimento ficar muuuito mais f√°cil. Em resumo, a ideia √© algo&nbsp;assim:</p>
<p>Imagine que voc√™ vai a um show e precisa guardar suas coisas na chapelaria (eu nem sabia que isso existia ü§î). Apenas algumas gavetas est√£o dispon√≠veis e voc√™ pode guardar um item por gaveta. Voc√™ pega e guarda suas coisas nessas gavetas, fecha, e est√° pronto para ir ao&nbsp;show.</p>
<p>A mem√≥ria do computador funciona mais ou menos assim. O computador parece um grande conjunto de gavetas, e cada gaveta tem um endere√ßo. Cada vez que tu armazena um item na mem√≥ria, o computador fornece um endere√ßo para guardar esse&nbsp;item.</p>
<p>E a√≠, se tu quiser armazenar m√∫ltiplos itens, existem duas maneiras principais de fazer isso: <strong>arrays</strong> e <strong>listas</strong>.</p>
<hr>
<h2>Arrays</h2>
<ul>
<li>S√£o blocos cont√≠guos de mem√≥ria (um ao lado do&nbsp;outro).</li>
<li>Cada elemento pode ser acessado <strong>diretamente</strong> pelo √≠ndice, permitindo uma leitura r√°pida.<ul>
<li>Isso significa que a opera√ß√£o de busca por posi√ß√£o √© O(1), ou seja,&nbsp;constante.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># acesso direto ao 20</span>
</code></pre></div>

<ul>
<li>O lado ruim do array √© que, se tu quiser adicionar mais um item e a gaveta seguinte estiver ocupada, ser√° necess√°rio solicitar ao computador uma √°rea de mem√≥ria maior para armazenar todos os itens e mover os existentes para&nbsp;l√°.</li>
<li>Ent√£o adicionar novos itens a um array √© algo que pode ser muito&nbsp;lento.</li>
<li>Deletar um elemento √© t√£o custoso quanto adicionar, todos os elementos seguintes precisam ser&nbsp;movidos.</li>
</ul>
<hr>
<h2>Listas&nbsp;encadeadas</h2>
<ul>
<li>Seus itens podem estar <strong>em qualquer lugar da mem√≥ria</strong>.</li>
<li>Cada item armazena o endere√ßo do pr√≥ximo item da&nbsp;lista.</li>
<li>Semelhante a uma ca√ßa ao tesouro, cada pista encontrada indica onde est√° a pr√≥xima&nbsp;etapa.</li>
<li>Adicionar um item √© simples, voc√™ coloca o item em qualquer lugar da mem√≥ria e atualiza o endere√ßo do item&nbsp;anterior.</li>
<li>Para deletar, √© t√£o simples quanto, basta alterar o endere√ßo do item anterior para apontar para o pr√≥ximo&nbsp;item.</li>
<li>O lado ruim da lista encadeada √© que, para acessar um elemento espec√≠fico (por exemplo, o √∫ltimo), voc√™ n√£o pode ir direto, precisa percorrer a lista <strong>item por item</strong> at√© chegar&nbsp;l√°.</li>
</ul>
<div class="highlight"><pre><span></span><code>  <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
      <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valor</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">valor</span> <span class="o">=</span> <span class="n">valor</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">proximo</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">proximo</span> <span class="o">=</span> <span class="n">b</span>

  <span class="c1"># Percorrendo</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">a</span>
  <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">valor</span><span class="p">)</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">proximo</span>
</code></pre></div>

<p>Explicando o c√≥digo acima:
1. Crio a&nbsp;classe <code>Node</code>, que armazena um valor&nbsp;(<code>valor</code>) e um ponteiro para o pr√≥ximo n√≥&nbsp;(<code>proximo</code>).
2. Crio dois&nbsp;n√≥s: <code>a</code> com valor 10&nbsp;e <code>b</code> com valor 20.
3.&nbsp;Ligo <code>a</code> ao <code>b</code> com <code>a.proximo = b</code>.
4. Percorro a lista&nbsp;com <code>while n:</code> imprimindo <code>n.valor</code> at√© chegar no final&nbsp;(<code>None</code>).</p>
<p>A sa√≠da pra esse&nbsp;c√≥digo:</p>
<div class="highlight"><pre><span></span><code><span class="mi">10</span>
<span class="mi">20</span>
</code></pre></div>

<hr>
<p>N√£o sei voc√™s, mas <strong>entender a diferen√ßa entre arrays e listas</strong> foi um verdadeiro estalo para mim. Como aprendi Python primeiro, eu meio que usava essas estruturas no autom√°tico‚Ä¶ ü•≤ 
Pode parecer algo √≥bvio ou at√© desnecess√°rio, afinal, lidamos com arrays e listas o tempo todo, mas foi incr√≠vel compreender <strong>por que as coisas funcionam do jeito que funcionam</strong>. Minha cabe√ßa finalmente come√ßou a encaixar as pe√ßas e perceber a l√≥gica por tr√°s das opera√ß√µes. Fiquei meio&nbsp;que:</p>
<p><img src="/images/cat-in-shock-surprises.gif" alt="gato surpreso" width="150"/></p>
<p>Aqui est√£o os tempos de execu√ß√£o para as opera√ß√µes mais comuns em arrays e listas&nbsp;encadeadas</p>
<p><img src="/images/array_lista.png" alt="tempo de execu√ß√£o" width="400"/></p>
<p>Acho importante trazer essa tabela, para que o entendimento sobre nota√ß√£o Big O se consolide e pra todos entenderem o impacto das nossas escolhas em diferentes&nbsp;situa√ß√µes.</p>
<p>A interpreta√ß√£o pra essa tabela de uma forma mais expl√≠cita&nbsp;seria:</p>
<ul>
<li>
<p><strong>Leitura</strong>:</p>
<ul>
<li>
<p><strong>Array ‚Üí O(1)</strong>:
    Em um array, cada posi√ß√£o tem um endere√ßo fixo na mem√≥ria. Ent√£o, se voc√™ quiser o 5¬∫ elemento, o computador vai direto nele de uma forma super r√°pida e em tempo&nbsp;constante.</p>
</li>
<li>
<p><strong>Lista ‚Üí O(n)</strong>:
    uma lista encadeada, cada elemento sabe apenas quem √© o pr√≥ximo. Ent√£o, para achar o 5¬∫ elemento, voc√™ precisa come√ßar do 1¬∫, depois o 2¬∫, depois o 3¬∫‚Ä¶ at√© chegar no 5¬∫. Quanto maior a lista, mais tempo&nbsp;demora.</p>
</li>
</ul>
</li>
<li>
<p><strong>Inser√ß√£o</strong>:</p>
<ul>
<li>
<p><strong>Array ‚Üí O(n)</strong>:
    Se o array estiver cheio e voc√™ quiser enfiar um novo item no meio, tem que ‚Äúempurrar‚Äù todos os outros elementos uma posi√ß√£o para frente. Isso pode levar bastante&nbsp;tempo.</p>
</li>
<li>
<p><strong>Lista ‚Üí O(1)</strong>:
    Se voc√™ j√° sabe a posi√ß√£o, inserir numa lista √© rapidinho, basta mudar quem aponta pra quem e&nbsp;pronto.</p>
</li>
</ul>
</li>
<li>
<p><strong>Dele√ß√£o</strong>:</p>
<ul>
<li>
<p><strong>Array ‚Üí O(n)</strong>:
    Se voc√™ remove um item no meio do array, precisa ‚Äúpuxar‚Äù todos os elementos da frente uma posi√ß√£o pra tr√°s para fechar o&nbsp;buraco.</p>
</li>
<li>
<p><strong>Lista ‚Üí O(1)</strong>:
    Assim como na inser√ß√£o, basta mudar os ponteiros para pular o item que voc√™ quer remover. N√£o mexe em mais&nbsp;ningu√©m.</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1>Ordena√ß√£o por&nbsp;sele√ß√£o</h1>
<p>O autor apresenta o algoritmo Selection Sort, que √© simples de implementar, mas n√£o muito eficiente.
A diferen√ßa entre arrays e listas em Python torna importante entender como o algoritmo percorre e manipula os&nbsp;elementos.</p>
<h3>Ideia do&nbsp;algoritmo</h3>
<ol>
<li>Encontrar o menor elemento da&nbsp;lista</li>
<li>Coloc√°-lo na primeira&nbsp;posi√ß√£o</li>
<li>Repetir para as posi√ß√µes seguintes at√© ordenar toda a&nbsp;lista</li>
</ol>
<h4>Implementa√ß√£o em&nbsp;Python:</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">busca_menor</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encontra o √≠ndice do menor elemento em um array.</span>

<span class="sd">    Par√¢metros:</span>
<span class="sd">    arr (list): Lista de elementos compar√°veis.</span>

<span class="sd">    Retorna:</span>
<span class="sd">    int: √çndice do menor elemento encontrado.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">menor</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">menor_indice</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">menor</span><span class="p">:</span>
            <span class="n">menor</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">menor_indice</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">menor_indice</span>

<span class="k">def</span> <span class="nf">ordenacao_por_selecao</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ordena uma lista usando o algoritmo de ordena√ß√£o por sele√ß√£o.</span>

<span class="sd">    A fun√ß√£o cria uma nova lista, removendo o menor elemento</span>
<span class="sd">    da lista original a cada itera√ß√£o e adicionando-o √† lista ordenada.</span>

<span class="sd">    Par√¢metros:</span>
<span class="sd">    arr (list): Lista de n√∫meros a serem ordenados.</span>

<span class="sd">    Retorna:</span>
<span class="sd">    list: Nova lista ordenada em ordem crescente.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">novo_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">menor</span> <span class="o">=</span> <span class="n">busca_menor</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">novo_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">menor</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">novo_arr</span>

<span class="nb">print</span><span class="p">(</span><span class="n">ordenacao_por_selecao</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span> <span class="c1"># Sa√≠da: [2, 3, 5, 6, 10]</span>
</code></pre></div>

<hr>
<h3>Complexidade e Big&nbsp;O</h3>
<ul>
<li>O selection sort precisa percorrer todos os elementos v√°rias&nbsp;vezes.</li>
<li>Para n elementos, ele faz aproximadamente n √ó n&nbsp;opera√ß√µes.</li>
<li>Isso significa que seu desempenho √©&nbsp;O(n¬≤).</li>
</ul>
<p>Este √© um exemplo cl√°ssico que mostra como <strong>algoritmos diferentes podem resolver o mesmo problema com efici√™ncias diferentes</strong>, destacando a import√¢ncia de escolher o algoritmo certo dependendo do tamanho e da estrutura dos&nbsp;dados.</p>
<hr>
<h2>Curiosidades</h2>
<ul>
<li>As listas em Python s√£o, na verdade, <strong>arrays</strong>.</li>
<li>O&nbsp;m√©todo <code>append</code> (adicionar no final) √© considerado de complexidade <strong>O(1)</strong> na m√©dia. Isso porque adicionar um item no final geralmente √© bem barato: s√≥ colocar no pr√≥ximo espa√ßo&nbsp;livre.</li>
<li>O ‚Äúcusto alto‚Äù aparece em opera√ß√µes&nbsp;como <code>insert</code> ou <code>remove</code> no meio da lista. A√≠ √© preciso deslocar todos os elementos seguintes, o que pode ser <strong>O(n)</strong>.</li>
<li>Uma forma de visualizar: pense numa pilha de pratos. Colocar ou tirar um prato do topo&nbsp;(como <code>append</code> e <code>pop</code>) √© f√°cil. Mas se voc√™ quiser enfiar ou tirar um prato do meio da pilha&nbsp;(<code>insert</code> ou <code>remove</code>), vai ter que mover todos os pratos que estavam em cima&nbsp;primeiro.</li>
</ul>
<hr>
<h2>Exerc√≠cios recomendados&nbsp;üë©üèª‚Äçüíªüíû</h2>
<p>Para refor√ßar o aprendizado, aqui v√£o alguns desafios&nbsp;pr√°ticos:</p>
<p><strong>LeetCode</strong></p>
<ul>
<li>
<p><a href="https://leetcode.com/problems/two-sum/description/">Two Sum</a> - cl√°ssico de&nbsp;arrays</p>
</li>
<li>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Best Time to Buy and Sell Stock</a> - Percorrer array com an√°lise de&nbsp;tempo</p>
</li>
<li>
<p><a href="https://leetcode.com/problems/merge-sorted-array/description/">Merge Sorted Array</a> - Manipula√ß√£o de listas&nbsp;ordenadas</p>
</li>
</ul>
<p><strong>Exercism</strong></p>
<ul>
<li><a href="https://exercism.org/tracks/python/exercises/isogram">Isogram</a> - Percorre strings/arrays verificando&nbsp;duplicatas</li>
</ul>
<hr>
<p>E assim, fechamos o segundo cap√≠tulo!
Espero que tenha sido √∫til e leve de ler&nbsp;üíÅüèª‚Äç‚ôÄÔ∏è‚ú®</p>

         <!-- Bot√µes de compartilhamento -->
        <div class="compartilhar" style="margin-top: 2em; display: flex; gap: 1em; align-items: center;">
          <strong>Compartilhar:</strong>

          <!-- LinkedIn -->
          <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://anapaula.org/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/"
            target="_blank" rel="noopener noreferrer" title="Compartilhar no LinkedIn">
            <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/linkedin.svg" alt="LinkedIn" width="24" height="24" style="vertical-align: middle;">
          </a>

          <!-- Telegram -->
          <a href="https://t.me/share/url?url=https://anapaula.org/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/"
             target="_blank" rel="noopener noreferrer" title="Compartilhar no Telegram">
            <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/telegram.svg" alt="Telegram" width="24" height="24" style="vertical-align: middle;">
          </a>

          <!-- WhatsApp -->
          <a href="https://wa.me/?text=https://anapaula.org/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/"
            target="_blank" rel="noopener noreferrer" title="Compartilhar no WhatsApp">
            <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/whatsapp.svg" alt="WhatsApp" width="24" height="24">
          </a>
        </div>
      </div><!-- /.entry-content -->
    </article>
  </section>

  <div id="comments" style="max-width: 700px;">
    <script src="https://utteranc.es/client.js"
      repo="aninhasalesp/meublog"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

        <footer id="footer" class="body">
                <p>Feito com amor, por <a href="https://github.com/aninhasalesp"> Ana Paula</a> ‚ù§Ô∏è</p>
        </footer><!-- /#footer -->

        <script>
            function toggleMenu() {
                const menu = document.getElementById('menu');
                const toggle = document.querySelector('.menu-toggle');

                menu.classList.toggle('active');
                toggle.classList.toggle('active');
            }
        </script>

</body>
</html>