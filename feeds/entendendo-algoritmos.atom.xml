<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>@aninhasalesp - Entendendo algoritmos</title><link href="/" rel="alternate"/><link href="/feeds/entendendo-algoritmos.atom.xml" rel="self"/><id>/</id><updated>2025-09-17T00:00:00-03:00</updated><entry><title>Explorando o livro ‚ÄúEntendendo Algoritmos‚Äù,¬†cap.3</title><link href="/2025/09/17/explorando-o-livro-entendendo-algoritmos-cap3/" rel="alternate"/><published>2025-09-17T00:00:00-03:00</published><updated>2025-09-17T00:00:00-03:00</updated><author><name>Ana Paula Sales</name></author><id>tag:None,2025-09-17:/2025/09/17/explorando-o-livro-entendendo-algoritmos-cap3/</id><summary type="html">&lt;p&gt;An√°lises e exerc√≠cios pr√°ticos sobre o Cap√≠tulo 3 do livro &amp;#8220;Entendendo Algoritmos&amp;#8221;, com sugest√µes de&amp;nbsp;desafios.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Terceiro cap√≠tulo da s√©rie de estudos sobre o livro &lt;a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf"&gt;Entendendo Algoritmos&lt;/a&gt; de Aditya Y.&amp;nbsp;Bhargava.&lt;/p&gt;
&lt;p&gt;Se voc√™ est√° acompanhando a s√©rie, j√° resumi os cap√≠tulos anteriores üëÄ, ent√£o volta l√° se tu tiver alguma d√∫vida:&lt;br&gt;
- &lt;a href="https://anapaula.org/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/"&gt;Cap√≠tulo 1 - Introdu√ß√£o a algoritmos&lt;/a&gt;&lt;br&gt;
- &lt;a href="https://anapaula.org/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/"&gt;Cap√≠tulo 2 - Ordena√ß√£o por&amp;nbsp;sele√ß√£o&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Oi, pessoal! Mais um resuminho do nosso livro querido&amp;nbsp;üòä &lt;/p&gt;
&lt;p&gt;Esse cap√≠tulo foi um dos que mais me tirou a sensa√ß√£o de que programa√ß√£o √© m√°gica. Bora entender recurs√£o e pilhas sem&amp;nbsp;medo?&lt;/p&gt;
&lt;p&gt;Neste cap√≠tulo, o autor explica de forma simples o conceito e o uso da &lt;strong&gt;recurs√£o&lt;/strong&gt;, dividindo a explica√ß√£o em caso base e caso recursivo. 
Ele sugere que voc√™, ao menos uma vez, analise uma fun√ß√£o recursiva com papel e caneta, acompanhando passo a passo, assim voc√™ entender√° como a fun√ß√£o&amp;nbsp;funciona.&lt;/p&gt;
&lt;h1&gt;Recurs√£o&lt;/h1&gt;
&lt;p&gt;√â a t√©cnica onde uma fun√ß√£o chama a si mesma para resolver um problema, dividindo-o em problemas menores. Devido ao fato de uma fun√ß√£o recursiva chamar a si mesma, √© mais f√°cil de escrev√™-la de forma errada e acabar em um loop infinito. Para que a recurs√£o funcione corretamente, ela deve conter um caso base para parar as chamadas e um caso recursivo que aproxime o problema da solu√ß√£o&amp;nbsp;final. &lt;/p&gt;
&lt;h2&gt;Como a recurs√£o&amp;nbsp;funciona:&lt;/h2&gt;
&lt;p&gt;Antes de mostrar um exemplo de recurs√£o, vamos entender como ela&amp;nbsp;funciona.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Caso base&lt;/strong&gt;: define quando a fun√ß√£o deve &lt;strong&gt;parar&lt;/strong&gt; de se chamar. Sem ele, a recurs√£o continuaria indefinidamente, causando&amp;nbsp;erro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Caso recursivo&lt;/strong&gt;: √© a parte em que a fun√ß√£o &lt;strong&gt;se chama novamente&lt;/strong&gt;, aproximando-se da solu√ß√£o final a cada&amp;nbsp;passo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Um exemplo cl√°ssico √© o c√°lculo do fatorial de um&amp;nbsp;n√∫mero::&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fatorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;# Caso Base&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;# Caso Recursivo&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fatorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fatorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;# Sa√≠da: 120&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Nesse&amp;nbsp;exemplo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Caso Base&lt;/strong&gt;: &lt;code&gt;n&lt;/code&gt; √© 0 ou 1, o fatorial √©&amp;nbsp;1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Caso Recursivo&lt;/strong&gt;:&amp;nbsp;Se &lt;code&gt;n&lt;/code&gt; √© maior que 1, o fatorial&amp;nbsp;√© &lt;code&gt;n * fatorial(n-1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Olha como fica quase po√©tico, cada n√∫mero chama o pr√≥ximo at√© o 1 dizer &amp;#8220;chega, agora volta&amp;#8221;. A√≠ a multiplica√ß√£o acontece no caminho de&amp;nbsp;volta.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Pilha&lt;/h1&gt;
&lt;p&gt;Suponha que voc√™ esteja fazendo um churrasco para os seus amigos. Voc√™ tem uma lista de afazeres em forma de uma pilha de notas adesivas. Quando voc√™ insere um item, ele √© colocado no topo da pilha. Quando voc√™ l√™ um item, l√™ apenas o item do topo da pilha e ele √© retirado da lista. Logo, sua lista de afazeres cont√©m apenas duas a√ß√µes: &lt;em&gt;push&lt;/em&gt; (inserir) e &lt;em&gt;pop&lt;/em&gt; (remover e&amp;nbsp;ler).&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/pilha.png" alt="pilha" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;Esta estrutura de dados √© chamada de pilha. A pilha √© uma estrutura de dados simples e n√≥s usamos o tempo todo sem&amp;nbsp;perceber.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Pilha de&amp;nbsp;chamadas&lt;/h1&gt;
&lt;p&gt;Sempre que uma fun√ß√£o √© chamada, o computador precisa ‚Äúlembrar‚Äù de onde ela parou para poder continuar depois.
Essa mem√≥ria tempor√°ria √© organizada numa &lt;strong&gt;pilha de chamadas&lt;/strong&gt; (call&amp;nbsp;stack).&lt;/p&gt;
&lt;p&gt;Funciona&amp;nbsp;assim:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A cada nova chamada de fun√ß√£o, o computador empilha informa√ß√µes sobre essa execu√ß√£o (como par√¢metros e vari√°veis&amp;nbsp;locais).&lt;/li&gt;
&lt;li&gt;Quando a fun√ß√£o termina, o computador desempilha esses dados e volta para o ponto&amp;nbsp;anterior.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A met√°fora do livro √© √≥tima, pense em uma pilha de pratos na cozinha. Voc√™ s√≥ consegue pegar (ou retirar) o prato que est√° por cima.  Assim tamb√©m funciona com fun√ß√µes, o √∫ltimo que entrou √© o primeiro que sai (&lt;span class="caps"&gt;LIFO&lt;/span&gt;: Last In, First&amp;nbsp;Out).&lt;/p&gt;
&lt;p&gt;Podemos visualizar isso com um exemplo simples em&amp;nbsp;Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cumprimenta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nome&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Oi,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nome&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;despedida&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;despedida&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Tchau!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;cumprimenta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Ana&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ordem de execu√ß√£o na&amp;nbsp;pilha:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cumprimenta(&amp;#8220;Ana&amp;#8221;) √© chamada ‚Üí vai para a&amp;nbsp;pilha.&lt;/li&gt;
&lt;li&gt;Dentro dela, despedida() √© chamada ‚Üí fica no&amp;nbsp;topo.&lt;/li&gt;
&lt;li&gt;despedida() roda e sai da&amp;nbsp;pilha.&lt;/li&gt;
&lt;li&gt;cumprimenta(&amp;#8220;Ana&amp;#8221;) roda at√© o fim e sai da&amp;nbsp;pilha.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ou seja, tudo organizado, prato por&amp;nbsp;prato.&lt;/p&gt;
&lt;p&gt;Esse exemplo j√° mostra que n√£o √© s√≥ recurs√£o que usa pilha, mas qualquer fun√ß√£o. A diferen√ßa √© que a recurs√£o for√ßa a pilha a crescer muito mais&amp;nbsp;r√°pido.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Pilha de chamadas com&amp;nbsp;recurs√£o&lt;/h1&gt;
&lt;p&gt;Com recurs√£o, essa pilha pode crescer bastante, porque a fun√ß√£o vai se chamando v√°rias vezes at√© chegar no caso&amp;nbsp;base.&lt;/p&gt;
&lt;p&gt;Exemplo simplificado&amp;nbsp;com &lt;code&gt;fatorial(3)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;O programa chama fatorial(3)
    &lt;span class="k"&gt;-&lt;/span&gt; empilha fatorial(3)

Para resolver, precisa de fatorial(2)
    &lt;span class="k"&gt;-&lt;/span&gt; empilha fatorial(2)

Para resolver, precisa de fatorial(1)
    &lt;span class="k"&gt;-&lt;/span&gt; empilha fatorial(1)

fatorial(1) chega no caso base e retorna 1
    &lt;span class="k"&gt;-&lt;/span&gt; desempilha fatorial(1)

Agora fatorial(2) consegue calcular 2 √ó 1 = 2
    &lt;span class="k"&gt;-&lt;/span&gt; desempilha fatorial(2)

Por fim, fatorial(3) calcula 3 √ó 2 = 6
    &lt;span class="k"&gt;-&lt;/span&gt; desempilha fatorial(3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;No fim, cada chamada s√≥ consegue terminar depois que a chamada menor retorna. 
√â por isso que &lt;strong&gt;definir bem o caso base √© t√£o importante&lt;/strong&gt;, sem ele, a fun√ß√£o nunca para de empilhar chamadas e acaba estourando a mem√≥ria (stack&amp;nbsp;overflow).&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/coffee.gif" alt="overflow" width="400"/&gt;&lt;/p&gt;
&lt;p&gt;Esse ‚Äúestouro da pilha‚Äù √© justamente de onde veio o nome do site &lt;a href="https://stackoverflow.com/questions"&gt;Stack Overflow&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Quando vi esse processo pela primeira vez, parecia uma esp√©cie de ‚Äúm√°gica‚Äù, como se o computador simplesmente soubesse de onde&amp;nbsp;voltar.&lt;/p&gt;
&lt;p&gt;Foi nesse momento que percebi que entender programa√ß√£o √© muito sobre desmistificar. N√£o √© dom, n√£o √© g√™nio, √© s√≥ empilhar e desempilhar com calma. 
Hoje, sempre que vejo um c√≥digo recursivo, tento imaginar essa pilha acontecendo em segundo plano, isso traz clareza e ainda transforma o ‚Äúeu n√£o nasci pra isso/nunca vou entender isso‚Äù para um ‚Äúhihi que legal‚Äù&amp;nbsp;üòé&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/chihuahua.gif" alt="cachorro" width="200"/&gt;&lt;/p&gt;
&lt;p&gt;Ent√£o, da pr√≥xima vez que voc√™ se perder num c√≥digo recursivo, respira: desenha a pilha, segue os passos, e lembra que n√£o √© m√°gica, √© s√≥ &lt;strong&gt;pr√°tica&lt;/strong&gt;!!!&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Curiosidades&amp;nbsp;üí°&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Uma recurs√£o muito comum fora da programa√ß√£o: bonecas russas (matryoshkas). Cada boneca guarda outra dentro, at√© que a √∫ltima (caso base) n√£o guarda mais&amp;nbsp;nenhuma.&lt;/li&gt;
&lt;li&gt;Algumas linguagens aplicam otimiza√ß√£o de recurs√£o de cauda (tail call optimization), que reaproveita os quadros da pilha para n√£o estourar a mem√≥ria em fun√ß√µes recursivas muito profundas. Python, por√©m, n√£o faz&amp;nbsp;isso.&lt;/li&gt;
&lt;li&gt;A pilha de chamadas √© invis√≠vel na maior parte do tempo, mas voc√™ j√° viu ela funcionando, quando o Python mostra um traceback (aquele erro cheio de setas, indicando em que fun√ß√£o a execu√ß√£o&amp;nbsp;estava).&lt;/li&gt;
&lt;li&gt;Muitas fun√ß√µes recursivas podem ser reescritas de forma iterativa (usando&amp;nbsp;la√ßos &lt;code&gt;for&lt;/code&gt; ou &lt;code&gt;while&lt;/code&gt;). Isso evita o risco de estouro da pilha em casos de chamadas muito&amp;nbsp;profundas.&lt;/li&gt;
&lt;li&gt;Para entender recurs√£o, voc√™ precisa primeiro entender recurs√£o.&amp;nbsp;üòÖ&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;Exerc√≠cios recomendados&amp;nbsp;üë©üèª‚Äçüíªüíû&lt;/h2&gt;
&lt;p&gt;Para refor√ßar o aprendizado, aqui v√£o alguns desafios&amp;nbsp;pr√°ticos:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/merge-two-sorted-lists/description/"&gt;Merge two sorted lists&lt;/a&gt; - D√° pra resolver recursivamente, tratando como o caso base quando uma lista chega ao&amp;nbsp;fim.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/climbing-stairs/description/"&gt;Climbing Stairs&lt;/a&gt; - Um problema cl√°ssico de recurs√£o + otimiza√ß√£o (parecido com&amp;nbsp;Fibonacci).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercism&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/exercises/flatten-array"&gt;Flatten Array&lt;/a&gt; - Recebe uma lista que pode conter sublistas e precisa retornar tudo ‚Äúachatado‚Äù em uma √∫nica&amp;nbsp;lista&lt;/li&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/concepts/recursion"&gt;Recurs√£o com Python&lt;/a&gt; - Refor√ßa o conceito de recurs√£o e tem o exerc√≠cio ‚ÄúLuhn‚Äù que admite uma abordagem&amp;nbsp;recursiva&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Desafio&amp;nbsp;extra&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Crie uma fun√ß√£o recursiva que percorre pastas e arquivos no seu computador (ou s√≥ numa lista aninhada simulada). Isso √© literalmente como muitos sistemas de arquivos&amp;nbsp;funcionam.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Espero que tenha aproveitado o conte√∫do!&amp;nbsp;‚ú®üíï&lt;/p&gt;
&lt;p&gt;Se tiver alguma sugest√£o de exerc√≠cio ou melhoria na explica√ß√£o, me conta aqui&amp;nbsp;ü´Çüåª&lt;/p&gt;</content><category term="Entendendo algoritmos"/></entry><entry><title>Explorando o livro ‚ÄúEntendendo Algoritmos‚Äù,¬†cap.2</title><link href="/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/" rel="alternate"/><published>2025-08-27T00:00:00-03:00</published><updated>2025-08-27T00:00:00-03:00</updated><author><name>Ana Paula Sales</name></author><id>tag:None,2025-08-27:/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/</id><summary type="html">&lt;p&gt;An√°lises e exerc√≠cios pr√°ticos sobre o Cap√≠tulo 2 do livro &amp;#8220;Entendendo Algoritmos&amp;#8221;, com sugest√µes de&amp;nbsp;desafios.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Segundo cap√≠tulo da s√©rie de estudos sobre o livro &lt;a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf"&gt;Entendendo Algoritmos&lt;/a&gt; de Aditya Y.&amp;nbsp;Bhargava.&lt;/p&gt;
&lt;p&gt;Espero que voc√™s tenham gostado da forma como estruturei o &lt;a href="https://anapaula.org/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/"&gt;primeiro cap√≠tulo&lt;/a&gt;, seguirei naquela mesma linha de racioc√≠nio e explica√ß√£o. Se voc√™ tiver alguma sugest√£o de exerc√≠cio ou melhoria na explica√ß√£o, me conta aqui que eu ficarei feliz em receber esse feedback&amp;nbsp;ü´Çüíï&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;No cap√≠tulo 2, o autor aprofunda dois conceitos fundamentais: &lt;strong&gt;estruturas de dados&lt;/strong&gt; (como arrays e listas) e a &lt;strong&gt;efici√™ncia dos algoritmos&lt;/strong&gt; (nota√ß√£o Big O). Para ilustrar isso, ele apresenta o algoritmo de &lt;strong&gt;ordena√ß√£o por sele√ß√£o&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Arrays e&amp;nbsp;Listas&lt;/h1&gt;
&lt;p&gt;Antes de falar em ordena√ß√£o, √© importante entender como os dados podem ser armazenados na mem√≥ria.&amp;nbsp;üëÄ&lt;/p&gt;
&lt;p&gt;O autor traz uma analogia que faz o entendimento ficar muuuito mais f√°cil. Em resumo, a ideia √© algo&amp;nbsp;assim:&lt;/p&gt;
&lt;p&gt;Imagine que voc√™ vai a um show e precisa guardar suas coisas na chapelaria (eu nem sabia que isso existia ü§î). Apenas algumas gavetas est√£o dispon√≠veis e voc√™ pode guardar um item por gaveta. Voc√™ pega e guarda suas coisas nessas gavetas, fecha, e est√° pronto para ir ao&amp;nbsp;show.&lt;/p&gt;
&lt;p&gt;A mem√≥ria do computador funciona mais ou menos assim. O computador parece um grande conjunto de gavetas, e cada gaveta tem um endere√ßo. Cada vez que tu armazena um item na mem√≥ria, o computador fornece um endere√ßo para guardar esse&amp;nbsp;item.&lt;/p&gt;
&lt;p&gt;E a√≠, se tu quiser armazenar m√∫ltiplos itens, existem duas maneiras principais de fazer isso: &lt;strong&gt;arrays&lt;/strong&gt; e &lt;strong&gt;listas&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Arrays&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;S√£o blocos cont√≠guos de mem√≥ria (um ao lado do&amp;nbsp;outro).&lt;/li&gt;
&lt;li&gt;Cada elemento pode ser acessado &lt;strong&gt;diretamente&lt;/strong&gt; pelo √≠ndice, permitindo uma leitura r√°pida.&lt;ul&gt;
&lt;li&gt;Isso significa que a opera√ß√£o de busca por posi√ß√£o √© O(1), ou seja,&amp;nbsp;constante.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c1"&gt;# acesso direto ao 20&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;O lado ruim do array √© que, se tu quiser adicionar mais um item e a gaveta seguinte estiver ocupada, ser√° necess√°rio solicitar ao computador uma √°rea de mem√≥ria maior para armazenar todos os itens e mover os existentes para&amp;nbsp;l√°.&lt;/li&gt;
&lt;li&gt;Ent√£o adicionar novos itens a um array √© algo que pode ser muito&amp;nbsp;lento.&lt;/li&gt;
&lt;li&gt;Deletar um elemento √© t√£o custoso quanto adicionar, todos os elementos seguintes precisam ser&amp;nbsp;movidos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Listas&amp;nbsp;encadeadas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Seus itens podem estar &lt;strong&gt;em qualquer lugar da mem√≥ria&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cada item armazena o endere√ßo do pr√≥ximo item da&amp;nbsp;lista.&lt;/li&gt;
&lt;li&gt;Semelhante a uma ca√ßa ao tesouro, cada pista encontrada indica onde est√° a pr√≥xima&amp;nbsp;etapa.&lt;/li&gt;
&lt;li&gt;Adicionar um item √© simples, voc√™ coloca o item em qualquer lugar da mem√≥ria e atualiza o endere√ßo do item&amp;nbsp;anterior.&lt;/li&gt;
&lt;li&gt;Para deletar, √© t√£o simples quanto, basta alterar o endere√ßo do item anterior para apontar para o pr√≥ximo&amp;nbsp;item.&lt;/li&gt;
&lt;li&gt;O lado ruim da lista encadeada √© que, para acessar um elemento espec√≠fico (por exemplo, o √∫ltimo), voc√™ n√£o pode ir direto, precisa percorrer a lista &lt;strong&gt;item por item&lt;/strong&gt; at√© chegar&amp;nbsp;l√°.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valor&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
          &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;valor&lt;/span&gt;
          &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proximo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proximo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

  &lt;span class="c1"&gt;# Percorrendo&lt;/span&gt;
  &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proximo&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Explicando o c√≥digo acima:
1. Crio a&amp;nbsp;classe &lt;code&gt;Node&lt;/code&gt;, que armazena um valor&amp;nbsp;(&lt;code&gt;valor&lt;/code&gt;) e um ponteiro para o pr√≥ximo n√≥&amp;nbsp;(&lt;code&gt;proximo&lt;/code&gt;).
2. Crio dois&amp;nbsp;n√≥s: &lt;code&gt;a&lt;/code&gt; com valor 10&amp;nbsp;e &lt;code&gt;b&lt;/code&gt; com valor 20.
3.&amp;nbsp;Ligo &lt;code&gt;a&lt;/code&gt; ao &lt;code&gt;b&lt;/code&gt; com &lt;code&gt;a.proximo = b&lt;/code&gt;.
4. Percorro a lista&amp;nbsp;com &lt;code&gt;while n:&lt;/code&gt; imprimindo &lt;code&gt;n.valor&lt;/code&gt; at√© chegar no final&amp;nbsp;(&lt;code&gt;None&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;A sa√≠da pra esse&amp;nbsp;c√≥digo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="mi"&gt;20&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;N√£o sei voc√™s, mas &lt;strong&gt;entender a diferen√ßa entre arrays e listas&lt;/strong&gt; foi um verdadeiro estalo para mim. Como aprendi Python primeiro, eu meio que usava essas estruturas no autom√°tico‚Ä¶ ü•≤ 
Pode parecer algo √≥bvio ou at√© desnecess√°rio, afinal, lidamos com arrays e listas o tempo todo, mas foi incr√≠vel compreender &lt;strong&gt;por que as coisas funcionam do jeito que funcionam&lt;/strong&gt;. Minha cabe√ßa finalmente come√ßou a encaixar as pe√ßas e perceber a l√≥gica por tr√°s das opera√ß√µes. Fiquei meio&amp;nbsp;que:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/cat-in-shock-surprises.gif" alt="gato surpreso" width="150"/&gt;&lt;/p&gt;
&lt;p&gt;Aqui est√£o os tempos de execu√ß√£o para as opera√ß√µes mais comuns em arrays e listas&amp;nbsp;encadeadas&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/array_lista.png" alt="tempo de execu√ß√£o" width="400"/&gt;&lt;/p&gt;
&lt;p&gt;Acho importante trazer essa tabela, para que o entendimento sobre nota√ß√£o Big O se consolide e pra todos entenderem o impacto das nossas escolhas em diferentes&amp;nbsp;situa√ß√µes.&lt;/p&gt;
&lt;p&gt;A interpreta√ß√£o pra essa tabela de uma forma mais expl√≠cita&amp;nbsp;seria:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Leitura&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Array ‚Üí O(1)&lt;/strong&gt;:
    Em um array, cada posi√ß√£o tem um endere√ßo fixo na mem√≥ria. Ent√£o, se voc√™ quiser o 5¬∫ elemento, o computador vai direto nele de uma forma super r√°pida e em tempo&amp;nbsp;constante.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lista ‚Üí O(n)&lt;/strong&gt;:
    uma lista encadeada, cada elemento sabe apenas quem √© o pr√≥ximo. Ent√£o, para achar o 5¬∫ elemento, voc√™ precisa come√ßar do 1¬∫, depois o 2¬∫, depois o 3¬∫‚Ä¶ at√© chegar no 5¬∫. Quanto maior a lista, mais tempo&amp;nbsp;demora.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Inser√ß√£o&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Array ‚Üí O(n)&lt;/strong&gt;:
    Se o array estiver cheio e voc√™ quiser enfiar um novo item no meio, tem que ‚Äúempurrar‚Äù todos os outros elementos uma posi√ß√£o para frente. Isso pode levar bastante&amp;nbsp;tempo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lista ‚Üí O(1)&lt;/strong&gt;:
    Se voc√™ j√° sabe a posi√ß√£o, inserir numa lista √© rapidinho, basta mudar quem aponta pra quem e&amp;nbsp;pronto.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dele√ß√£o&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Array ‚Üí O(n)&lt;/strong&gt;:
    Se voc√™ remove um item no meio do array, precisa ‚Äúpuxar‚Äù todos os elementos da frente uma posi√ß√£o pra tr√°s para fechar o&amp;nbsp;buraco.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lista ‚Üí O(1)&lt;/strong&gt;:
    Assim como na inser√ß√£o, basta mudar os ponteiros para pular o item que voc√™ quer remover. N√£o mexe em mais&amp;nbsp;ningu√©m.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1&gt;Ordena√ß√£o por&amp;nbsp;sele√ß√£o&lt;/h1&gt;
&lt;p&gt;O autor apresenta o algoritmo Selection Sort, que √© simples de implementar, mas n√£o muito eficiente.
A diferen√ßa entre arrays e listas em Python torna importante entender como o algoritmo percorre e manipula os&amp;nbsp;elementos.&lt;/p&gt;
&lt;h3&gt;Ideia do&amp;nbsp;algoritmo&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar o menor elemento da&amp;nbsp;lista&lt;/li&gt;
&lt;li&gt;Coloc√°-lo na primeira&amp;nbsp;posi√ß√£o&lt;/li&gt;
&lt;li&gt;Repetir para as posi√ß√µes seguintes at√© ordenar toda a&amp;nbsp;lista&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Implementa√ß√£o em&amp;nbsp;Python:&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;busca_menor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Encontra o √≠ndice do menor elemento em um array.&lt;/span&gt;

&lt;span class="sd"&gt;    Par√¢metros:&lt;/span&gt;
&lt;span class="sd"&gt;    arr (list): Lista de elementos compar√°veis.&lt;/span&gt;

&lt;span class="sd"&gt;    Retorna:&lt;/span&gt;
&lt;span class="sd"&gt;    int: √çndice do menor elemento encontrado.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;menor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;menor_indice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;menor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;menor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;menor_indice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;menor_indice&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ordenacao_por_selecao&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Ordena uma lista usando o algoritmo de ordena√ß√£o por sele√ß√£o.&lt;/span&gt;

&lt;span class="sd"&gt;    A fun√ß√£o cria uma nova lista, removendo o menor elemento&lt;/span&gt;
&lt;span class="sd"&gt;    da lista original a cada itera√ß√£o e adicionando-o √† lista ordenada.&lt;/span&gt;

&lt;span class="sd"&gt;    Par√¢metros:&lt;/span&gt;
&lt;span class="sd"&gt;    arr (list): Lista de n√∫meros a serem ordenados.&lt;/span&gt;

&lt;span class="sd"&gt;    Retorna:&lt;/span&gt;
&lt;span class="sd"&gt;    list: Nova lista ordenada em ordem crescente.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;novo_arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="n"&gt;menor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;busca_menor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;novo_arr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;novo_arr&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ordenacao_por_selecao&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="c1"&gt;# Sa√≠da: [2, 3, 5, 6, 10]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;h3&gt;Complexidade e Big&amp;nbsp;O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;O selection sort precisa percorrer todos os elementos v√°rias&amp;nbsp;vezes.&lt;/li&gt;
&lt;li&gt;Para n elementos, ele faz aproximadamente n √ó n&amp;nbsp;opera√ß√µes.&lt;/li&gt;
&lt;li&gt;Isso significa que seu desempenho √©&amp;nbsp;O(n¬≤).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Este √© um exemplo cl√°ssico que mostra como &lt;strong&gt;algoritmos diferentes podem resolver o mesmo problema com efici√™ncias diferentes&lt;/strong&gt;, destacando a import√¢ncia de escolher o algoritmo certo dependendo do tamanho e da estrutura dos&amp;nbsp;dados.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Curiosidades&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;As listas em Python s√£o, na verdade, &lt;strong&gt;arrays&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;O&amp;nbsp;m√©todo &lt;code&gt;append&lt;/code&gt; (adicionar no final) √© considerado de complexidade &lt;strong&gt;O(1)&lt;/strong&gt; na m√©dia. Isso porque adicionar um item no final geralmente √© bem barato: s√≥ colocar no pr√≥ximo espa√ßo&amp;nbsp;livre.&lt;/li&gt;
&lt;li&gt;O ‚Äúcusto alto‚Äù aparece em opera√ß√µes&amp;nbsp;como &lt;code&gt;insert&lt;/code&gt; ou &lt;code&gt;remove&lt;/code&gt; no meio da lista. A√≠ √© preciso deslocar todos os elementos seguintes, o que pode ser &lt;strong&gt;O(n)&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Uma forma de visualizar: pense numa pilha de pratos. Colocar ou tirar um prato do topo&amp;nbsp;(como &lt;code&gt;append&lt;/code&gt; e &lt;code&gt;pop&lt;/code&gt;) √© f√°cil. Mas se voc√™ quiser enfiar ou tirar um prato do meio da pilha&amp;nbsp;(&lt;code&gt;insert&lt;/code&gt; ou &lt;code&gt;remove&lt;/code&gt;), vai ter que mover todos os pratos que estavam em cima&amp;nbsp;primeiro.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Exerc√≠cios recomendados&amp;nbsp;üë©üèª‚Äçüíªüíû&lt;/h2&gt;
&lt;p&gt;Para refor√ßar o aprendizado, aqui v√£o alguns desafios&amp;nbsp;pr√°ticos:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/two-sum/description/"&gt;Two Sum&lt;/a&gt; - cl√°ssico de&amp;nbsp;arrays&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Best Time to Buy and Sell Stock&lt;/a&gt; - Percorrer array com an√°lise de&amp;nbsp;tempo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/merge-sorted-array/description/"&gt;Merge Sorted Array&lt;/a&gt; - Manipula√ß√£o de listas&amp;nbsp;ordenadas&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercism&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/exercises/isogram"&gt;Isogram&lt;/a&gt; - Percorre strings/arrays verificando&amp;nbsp;duplicatas&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;E assim, fechamos o segundo cap√≠tulo!
Espero que tenha sido √∫til e leve de ler&amp;nbsp;üíÅüèª‚Äç‚ôÄÔ∏è‚ú®&lt;/p&gt;</content><category term="Entendendo algoritmos"/></entry><entry><title>Explorando o livro ‚ÄúEntendendo Algoritmos‚Äù,¬†cap.1</title><link href="/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/" rel="alternate"/><published>2025-08-12T00:00:00-03:00</published><updated>2025-08-12T00:00:00-03:00</updated><author><name>Ana Paula Sales</name></author><id>tag:None,2025-08-12:/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/</id><summary type="html">&lt;p&gt;An√°lises e exerc√≠cios pr√°ticos sobre o Cap√≠tulo 1 do livro &amp;#8220;Entendendo Algoritmos&amp;#8221;, com sugest√µes de&amp;nbsp;desafios.&lt;/p&gt;</summary><content type="html">&lt;p&gt;In√≠cio de uma s√©rie de estudos sobre o livro &lt;a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf"&gt;Entendendo Algoritmos&lt;/a&gt; de Aditya Y.&amp;nbsp;Bhargava. &lt;/p&gt;
&lt;p&gt;Esse livro foi indicado por uma amiga, &lt;a href="https://github.com/anapaulamendes"&gt;Ana Paula Mendes&lt;/a&gt;, e eu n√£o imaginava o quanto iria gostar. A leitura √© leve, clara e muito acess√≠vel. Se voc√™, como eu, tem dificuldade em manter a const√¢ncia em leituras t√©cnicas, esse livro √© um achado, f√°cil de entender, √≥timo para aprender ou revisar&amp;nbsp;conceitos. &lt;/p&gt;
&lt;p&gt;Ele apresenta ideias da ci√™ncia da computa√ß√£o que est√£o no nosso dia a dia, muitas vezes sem que a gente&amp;nbsp;perceba.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/livro1.jpg" alt="capa do livro" width="400"/&gt;&lt;/p&gt;
&lt;p&gt;Uma das coisas que mais me chamam aten√ß√£o nesse livro √© o jeito como o autor ensina, sempre com exemplos. Em vez de encher de s√≠mbolos e f√≥rmulas, ele quer que a gente visualize os conceitos. Ele acredita, e eu concordo, que aprendemos melhor quando conseguimos relacionar o conte√∫do com algo que j√° conhecemos. E, pra isso, os exemplos ajudam&amp;nbsp;muito. &lt;/p&gt;
&lt;p&gt;E o melhor √© que ele desenha ü§©! 
Sabe aquela frase ‚Äúquer que eu desenhe pra voc√™ entender‚Äù? Eu respondo ‚Äúsim, por favorrrrr!‚Äù e ele realmente desenha. √â maravilhoso&amp;nbsp;‚ú®. &lt;/p&gt;
&lt;p&gt;D√° pra sentir que tudo foi pensado com cuidado, desde o conte√∫do, os exemplos ilustrados at√© a recapitula√ß√£o no fim de cada&amp;nbsp;cap√≠tulo. &lt;/p&gt;
&lt;p&gt;Depois dessa introdu√ß√£o, bora ver o que o cap√≠tulo 1&amp;nbsp;ensina.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/hahahaha-gif.gif" alt="gif" width="100"/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;A busca bin√°ria em&amp;nbsp;resumo&lt;/h1&gt;
&lt;p&gt;Pensa numa lista telef√¥nica com &lt;strong&gt;1 milh√£o de nomes&lt;/strong&gt;. Olhar folha por folha seria um pesadelo, n√©? 
Agora, e se eu te dissesse que d√° para encontrar qualquer nome em no &lt;strong&gt;m√°ximo 20 tentativas&lt;/strong&gt;?&amp;nbsp;üëÄ&lt;/p&gt;
&lt;p&gt;O truque √© simples: a cada etapa, tu elimina metade das op√ß√µes. Comece considerando o elemento que est√° bem no meio da sequ√™ncia. Em uma lista telef√¥nica, isso seria abrir o livro bem no meio. Em uma lista com 10 itens, isso seria pegar o 5o item. Agora compare esse item do meio com o que voc√™ est√° buscando: se eles forem iguais, parab√©ns, voc√™ encontrou o que procurava! Agora, se o item que voc√™ encontrou for &lt;span class="caps"&gt;MAIOR&lt;/span&gt; que o item que voc√™ procura (no caso de nomes em uma lista telef√¥nica, pense em qual nome vem primeiro na ordem alfab√©tica), quer dizer que o item buscado est√° na primeira metade da lista. Caso contr√°rio, o item est√° na segunda metade da lista. E assim voc√™ consegue cortar a lista pela &lt;em&gt;metade&lt;/em&gt; apenas comparando o item procurado com o item do meio. Depois disso, basta pegar a parte que voc√™ selecionou e aplicar a mesma estrat√©gia, checando o item do meio e descartando metade da lista.
&lt;strong&gt;Observa√ß√£o&lt;/strong&gt;: Essa t√©cnica s√≥ funciona se a lista de itens estiver&amp;nbsp;ordenada!&lt;/p&gt;
&lt;p&gt;E o mais legal √© que, mesmo que a lista dobre de tamanho, tu s√≥ precisa de &lt;strong&gt;mais uma&lt;/strong&gt; etapa para chegar ao resultado.&amp;nbsp;ü§ì&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exemplo&lt;/strong&gt;:
Para facilitar a conta, vamos pegar uma lista menor de 128 nomes e calcular o n√∫mero m√°ximo de etapas que levar√≠amos para encontrar um nome espec√≠fico. Logo em seguida, dobramos o tamanho da lista e vemos que isso adiciona apenas mais uma&amp;nbsp;etapa:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;etapas&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;//=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="n"&gt;etapas&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;etapas&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# 7&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# 8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Observa√ß√£o importante&lt;/strong&gt;: numa lista telef√¥nica f√≠sica, a gente j√° sabe pular quase direto para a letra certa, o que lembra mais o funcionamento de um hashmap (ou dict no Python), que encontra um item em tempo constante. Mas no computador, quando temos apenas uma lista ordenada&amp;nbsp;(como &lt;code&gt;[1, 3, 5, 7, 9, 11, 13]&lt;/code&gt;), n√£o existe esse ‚Äúpulo m√°gico‚Äù, √© a√≠ que a busca bin√°ria pode ajudar, cortando a lista ao meio de forma sistem√°tica at√© encontrar (ou concluir que o elemento n√£o est√°&amp;nbsp;l√°).&lt;/p&gt;
&lt;p&gt;Legal n√©? Isso √© ci√™ncia da computa√ß√£o!!&amp;nbsp;üíÅ‚Äç‚ôÄÔ∏è‚ú®&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Exemplos b√°sicos de busca&amp;nbsp;bin√°ria:&lt;/h2&gt;
&lt;p&gt;Pense em um n√∫mero entre 1 e 100. D√° para adivinhar em, no m√°ximo, 7&amp;nbsp;tentativas:&lt;/p&gt;
&lt;p&gt;Minha primeira pergunta: &amp;#8220;√â&amp;nbsp;50?&amp;#8221;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se voc√™ disser &amp;#8220;maior&amp;#8221;, eu sei que est√° entre 51 e&amp;nbsp;100&lt;/li&gt;
&lt;li&gt;Se disser &amp;#8220;menor&amp;#8221;, est√° entre 1 e&amp;nbsp;49&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Segunda pergunta: Digamos que seja maior que 50. &amp;#8220;√â 75?&amp;#8221; (meio entre 51 e&amp;nbsp;100)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maior? Est√° entre 76 e&amp;nbsp;100&lt;/li&gt;
&lt;li&gt;Menor? Est√° entre 51 e&amp;nbsp;74&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E assim por diante, sempre eliminando metade das&amp;nbsp;possibilidades.&lt;/p&gt;
&lt;h3&gt;Vamos ver como fica com uma quantidade maior de&amp;nbsp;n√∫meros:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Itens na lista&lt;/th&gt;
&lt;th&gt;Busca linear (tentativas)&lt;/th&gt;
&lt;th&gt;Busca bin√°ria (tentativas)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.000&lt;/td&gt;
&lt;td&gt;at√© 1.000&lt;/td&gt;
&lt;td&gt;at√© 10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.000.000&lt;/td&gt;
&lt;td&gt;at√© 1.000.000&lt;/td&gt;
&lt;td&gt;at√© 20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Sim, 20 tentativas para encontrar algo entre 1 milh√£o de op√ß√µes!&amp;nbsp;üöÄ&lt;/p&gt;
&lt;p&gt;Esse ‚Äúmilagre‚Äù da busca bin√°ria acontece por causa de um conceito chamado &lt;strong&gt;logaritmo&lt;/strong&gt;, e j√° j√° eu te mostro o&amp;nbsp;porqu√™.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Agora que voc√™ j√° entendeu a busca bin√°ria, vamos entrar em mais tr√™s pontos que andam de m√£os dadas: &lt;strong&gt;logaritmos, tempo de execu√ß√£o e nota√ß√£o Big O&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Preparei um resumo r√°pido de cada um, do jeito que fez sentido pra mim.
Se em algum momento ficar confuso, n√£o tem problema, d√° uma olhada no livro que √© sucesso&amp;nbsp;ü´Çüíñ&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Logaritmos:&lt;/h2&gt;
&lt;p&gt;O n√∫mero m√°ximo de tentativas na busca bin√°ria √© dado por log‚ÇÇ(n), logaritmo na base 2 de&amp;nbsp;n.&lt;/p&gt;
&lt;p&gt;Se o nome assusta, pensa&amp;nbsp;assim:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;log‚ÇÇ(n) √© o n√∫mero de vezes que voc√™ precisa dividir n por 2 at√© chegar em&amp;nbsp;1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exemplo&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;log‚ÇÇ(128) = 7, 7 cortes ao meio at√© sobrar 1&amp;nbsp;item&lt;/li&gt;
&lt;li&gt;log‚ÇÇ(256) = 8, s√≥ mais uma etapa, mesmo dobrando o tamanho da&amp;nbsp;lista&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A base &amp;#8220;2&amp;#8221; vem justamente porque a cada passo cortamos a lista &lt;strong&gt;pela metade&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Tempo de&amp;nbsp;execu√ß√£o:&lt;/h2&gt;
&lt;p&gt;Sempre que falamos sobre um algoritmo, √© importante pensar no tempo de execu√ß√£o, quanto esfor√ßo (ou quantos passos) ele precisa para chegar ao&amp;nbsp;resultado.&lt;/p&gt;
&lt;p&gt;Na &lt;strong&gt;busca linear&lt;/strong&gt; (a pesquisa simples), verificamos item por&amp;nbsp;item:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lista com 100 n√∫meros ‚Üí at√© 100&amp;nbsp;tentativas&lt;/li&gt;
&lt;li&gt;Lista com 4 bilh√µes de n√∫meros ‚Üí at√© 4 bilh√µes de&amp;nbsp;tentativas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O tempo de execu√ß√£o cresce na mesma propor√ß√£o que o tamanho da lista. Chamamos isso de &lt;strong&gt;tempo linear&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;busca bin√°ria&lt;/strong&gt; √© um outro&amp;nbsp;mundo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lista com 100 n√∫meros ‚Üí no m√°ximo 7&amp;nbsp;tentativas&lt;/li&gt;
&lt;li&gt;Lista com 4 bilh√µes ‚Üí no m√°ximo 32&amp;nbsp;tentativas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Isso acontece porque a busca bin√°ria corta as possibilidades pela metade a cada passo. Esse tipo de crescimento √© chamado de &lt;strong&gt;tempo logar√≠tmico&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/image-4.png" alt="tempo de execu√ß√£o" width="400"/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Nota√ß√£o Big&amp;nbsp;O&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;nota√ß√£o Big O&lt;/strong&gt; √© um jeito de medir a efici√™ncia de um algoritmo, mostrando como o &lt;strong&gt;tempo de execu√ß√£o&lt;/strong&gt; cresce conforme aumentamos o tamanho da&amp;nbsp;entrada.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O(log n), tempo logar√≠tmico (ex: pesquisa&amp;nbsp;bin√°ria)&lt;/li&gt;
&lt;li&gt;O(n), tempo linear (ex: pesquisa&amp;nbsp;simples)&lt;/li&gt;
&lt;li&gt;O(n * log n), um algoritmo r√°pido de ordena√ß√£o, como quicksort (Cap√≠tulo&amp;nbsp;4)&lt;/li&gt;
&lt;li&gt;O(n¬≤), um algoritmo de ordena√ß√£o mais lenta, como ordena√ß√£o por sele√ß√£o (Cap√≠tulo&amp;nbsp;2).&lt;/li&gt;
&lt;li&gt;O(n!), um algoritmo extremamente lento, como o do caixeiro viajante (Cap√≠tulo&amp;nbsp;1).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O livro ilustra isso de forma bem visual e intuitiva: cresce linearmente, cresce em log, cresce muito, cresce lento&amp;#8230; e por a√≠&amp;nbsp;vai. &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Agora que vimos como a busca bin√°ria funciona, vale notar que ela n√£o est√° restrita a livros, ela aparece em v√°rias situa√ß√µes do nosso dia a&amp;nbsp;dia&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sistemas de busca (Google, WhatsApp, Spotify)&lt;/strong&gt;: por tr√°s, usam varia√ß√µes de busca bin√°ria em listas ordenadas ou&amp;nbsp;√≠ndices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filtragem de dados&lt;/strong&gt;: encontrar rapidamente um registro espec√≠fico em planilhas ou bases de dados&amp;nbsp;grandes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depura√ß√£o de c√≥digo&lt;/strong&gt;: reduzir o espa√ßo do problema pela metade a cada teste para achar onde o bug&amp;nbsp;est√°.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Observa√ß√£o&lt;/strong&gt;: para que a busca bin√°ria funcione, os dados precisam estar&amp;nbsp;ordenados.&lt;/p&gt;
&lt;h2&gt;Vamos praticar&amp;nbsp;rapidinho?&lt;/h2&gt;
&lt;p&gt;Aqui est√° uma lista ordenada de&amp;nbsp;n√∫meros: &lt;code&gt;[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Tente encontrar o n√∫mero 22 de duas&amp;nbsp;formas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Busca linear:&lt;/strong&gt; V√° um a um desde o&amp;nbsp;2.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Busca bin√°ria:&lt;/strong&gt; Comece no meio, elimine metade a cada&amp;nbsp;passo.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Compare quantos passos cada m√©todo&amp;nbsp;precisou&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Curiosidades&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;O git tem uma funcionalidade chamada &lt;a href="https://git-scm.com/docs/git-bisect"&gt;&lt;code&gt;git bisect&lt;/code&gt;&lt;/a&gt; que usa busca bin√°ria para ajudar desenvolvedores a encontrarem&amp;nbsp;bug&lt;/li&gt;
&lt;li&gt;Se o item que estamos buscando for o primeiro item da lista, esse √© o melhor caso na busca linear e o pior caso na busca&amp;nbsp;bin√°ria&lt;/li&gt;
&lt;li&gt;A implementa√ß√£o&amp;nbsp;do &lt;code&gt;sortedcontainers&lt;/code&gt; usa busca bin√°ria (a partir do m√≥dulo bisect), &lt;a href="https://grantjenks.com/docs/sortedcontainers/_modules/sortedcontainers/sortedlist.html#SortedList"&gt;veja&amp;nbsp;aqui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Exerc√≠cios recomendados&amp;nbsp;üë©üèª‚Äçüíªüíû&lt;/h2&gt;
&lt;p&gt;Para refor√ßar o aprendizado, aqui v√£o alguns desafios&amp;nbsp;pr√°ticos:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/binary-search/description/"&gt;Binary Search&lt;/a&gt; ‚Äî implementa√ß√£o&amp;nbsp;direta.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/search-insert-position/description/"&gt;Search Insert Position&lt;/a&gt; ‚Äî varia√ß√£o para encontrar onde inserir um&amp;nbsp;n√∫mero.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/first-bad-version/description/"&gt;First Bad Version&lt;/a&gt; ‚Äî busca bin√°ria aplicada em &lt;span class="caps"&gt;API&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercism&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/exercises/binary-search"&gt;Binary Search (Python Track)&lt;/a&gt; ‚Äî implementa√ß√£o e&amp;nbsp;testes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Dica: resolva primeiro o problema sem olhar a solu√ß√£o e depois compare com implementa√ß√µes&amp;nbsp;otimizadas.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;E assim come√ßa meu roadmap de estudo: cada cap√≠tulo do livro vem acompanhado de exerc√≠cios para fixar o&amp;nbsp;conte√∫do.&lt;/p&gt;</content><category term="Entendendo algoritmos"/></entry></feed>