<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>@aninhasalesp - Entendendo algoritmos</title><link href="/" rel="alternate"/><link href="/feeds/entendendo-algoritmos.atom.xml" rel="self"/><id>/</id><updated>2025-08-12T00:00:00-03:00</updated><entry><title>Explorando o livro “Entendendo Algoritmos”, cap.1</title><link href="/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/" rel="alternate"/><published>2025-08-12T00:00:00-03:00</published><updated>2025-08-12T00:00:00-03:00</updated><author><name>Ana Paula Sales</name></author><id>tag:None,2025-08-12:/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/</id><summary type="html">&lt;p&gt;Análises e exercícios práticos sobre o Capítulo 1 do livro &amp;#8220;Entendendo Algoritmos&amp;#8221;, com sugestões de&amp;nbsp;desafios.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Início de uma série de estudos sobre o livro &lt;a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf"&gt;Entendendo Algoritmos&lt;/a&gt; de Aditya Y.&amp;nbsp;Bhargava. &lt;/p&gt;
&lt;p&gt;Esse livro foi indicado por uma amiga, &lt;a href="https://github.com/anapaulamendes"&gt;Ana Paula Mendes&lt;/a&gt;, e eu não imaginava o quanto iria gostar. A leitura é leve, clara e muito acessível. Se você, como eu, tem dificuldade em manter a constância em leituras técnicas, esse livro é um achado, fácil de entender, ótimo para aprender ou revisar&amp;nbsp;conceitos. &lt;/p&gt;
&lt;p&gt;Ele apresenta ideias da ciência da computação que estão no nosso dia a dia, muitas vezes sem que a gente&amp;nbsp;perceba.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/livro1.jpg" alt="capa do livro" width="400"/&gt;&lt;/p&gt;
&lt;p&gt;Uma das coisas que mais me chamam atenção nesse livro é o jeito como o autor ensina, sempre com exemplos. Em vez de encher de símbolos e fórmulas, ele quer que a gente visualize os conceitos. Ele acredita, e eu concordo, que aprendemos melhor quando conseguimos relacionar o conteúdo com algo que já conhecemos. E, pra isso, os exemplos ajudam&amp;nbsp;muito. &lt;/p&gt;
&lt;p&gt;E o melhor é que ele desenha 🤩! 
Sabe aquela frase “quer que eu desenhe pra você entender”? Eu respondo “sim, por favorrrrr!” e ele realmente desenha. É maravilhoso&amp;nbsp;✨. &lt;/p&gt;
&lt;p&gt;Dá pra sentir que tudo foi pensado com cuidado, desde o conteúdo, os exemplos ilustrados até a recapitulação no fim de cada&amp;nbsp;capítulo. &lt;/p&gt;
&lt;p&gt;Depois dessa introdução, bora ver o que o capítulo 1&amp;nbsp;ensina.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/hahahaha-gif.gif" alt="gif" width="100"/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;A busca binária em&amp;nbsp;resumo&lt;/h1&gt;
&lt;p&gt;Pensa numa lista telefônica com &lt;strong&gt;1 milhão de nomes&lt;/strong&gt;. Olhar folha por folha seria um pesadelo, né? 
Agora, e se eu te dissesse que dá para encontrar qualquer nome em no &lt;strong&gt;máximo 20 tentativas&lt;/strong&gt;?&amp;nbsp;👀&lt;/p&gt;
&lt;p&gt;O truque é simples: a cada etapa, tu elimina metade das opções. Comece considerando o elemento que está bem no meio da sequência. Em uma lista telefônica, isso seria abrir o livro bem no meio. Em uma lista com 10 itens, isso seria pegar o 5o item. Agora compare esse item do meio com o que você está buscando: se eles forem iguais, parabéns, você encontrou o que procurava! Agora, se o item que você encontrou for &lt;span class="caps"&gt;MAIOR&lt;/span&gt; que o item que você procura (no caso de nomes em uma lista telefônica, pense em qual nome vem primeiro na ordem alfabética), quer dizer que o item buscado está na primeira metade da lista. Caso contrário, o item está na segunda metade da lista. E assim você consegue cortar a lista pela &lt;em&gt;metade&lt;/em&gt; apenas comparando o item procurado com o item do meio. Depois disso, basta pegar a parte que você selecionou e aplicar a mesma estratégia, checando o item do meio e descartando metade da lista.
&lt;strong&gt;Observação&lt;/strong&gt;: Essa técnica só funciona se a lista de itens estiver&amp;nbsp;ordenada!&lt;/p&gt;
&lt;p&gt;E o mais legal é que, mesmo que a lista dobre de tamanho, tu só precisa de &lt;strong&gt;mais uma&lt;/strong&gt; etapa para chegar ao resultado.&amp;nbsp;🤓&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exemplo&lt;/strong&gt;:
Para facilitar a conta, vamos pegar uma lista menor de 128 nomes e calcular o número máximo de etapas que levaríamos para encontrar um nome específico. Logo em seguida, dobramos o tamanho da lista e vemos que isso adiciona apenas mais uma&amp;nbsp;etapa:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;etapas&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;//=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="n"&gt;etapas&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;etapas&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# 7&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# 8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Observação importante&lt;/strong&gt;: numa lista telefônica física, a gente já sabe pular quase direto para a letra certa, o que lembra mais o funcionamento de um hashmap (ou dict no Python), que encontra um item em tempo constante. Mas no computador, quando temos apenas uma lista ordenada&amp;nbsp;(como &lt;code&gt;[1, 3, 5, 7, 9, 11, 13]&lt;/code&gt;), não existe esse “pulo mágico”, é aí que a busca binária pode ajudar, cortando a lista ao meio de forma sistemática até encontrar (ou concluir que o elemento não está&amp;nbsp;lá).&lt;/p&gt;
&lt;p&gt;Legal né? Isso é ciência da computação!!&amp;nbsp;💁‍♀️✨&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Exemplos básicos de busca&amp;nbsp;binária:&lt;/h2&gt;
&lt;p&gt;Pense em um número entre 1 e 100. Dá para adivinhar em, no máximo, 7&amp;nbsp;tentativas:&lt;/p&gt;
&lt;p&gt;Minha primeira pergunta: &amp;#8220;É&amp;nbsp;50?&amp;#8221;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se você disser &amp;#8220;maior&amp;#8221;, eu sei que está entre 51 e&amp;nbsp;100&lt;/li&gt;
&lt;li&gt;Se disser &amp;#8220;menor&amp;#8221;, está entre 1 e&amp;nbsp;49&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Segunda pergunta: Digamos que seja maior que 50. &amp;#8220;É 75?&amp;#8221; (meio entre 51 e&amp;nbsp;100)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maior? Está entre 76 e&amp;nbsp;100&lt;/li&gt;
&lt;li&gt;Menor? Está entre 51 e&amp;nbsp;74&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E assim por diante, sempre eliminando metade das&amp;nbsp;possibilidades.&lt;/p&gt;
&lt;h3&gt;Vamos ver como fica com uma quantidade maior de&amp;nbsp;números:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Itens na lista&lt;/th&gt;
&lt;th&gt;Busca linear (tentativas)&lt;/th&gt;
&lt;th&gt;Busca binária (tentativas)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.000&lt;/td&gt;
&lt;td&gt;até 1.000&lt;/td&gt;
&lt;td&gt;até 10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.000.000&lt;/td&gt;
&lt;td&gt;até 1.000.000&lt;/td&gt;
&lt;td&gt;até 20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Sim, 20 tentativas para encontrar algo entre 1 milhão de opções!&amp;nbsp;🚀&lt;/p&gt;
&lt;p&gt;Esse “milagre” da busca binária acontece por causa de um conceito chamado &lt;strong&gt;logaritmo&lt;/strong&gt;, e já já eu te mostro o&amp;nbsp;porquê.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Agora que você já entendeu a busca binária, vamos entrar em mais três pontos que andam de mãos dadas: &lt;strong&gt;logaritmos, tempo de execução e notação Big O&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Preparei um resumo rápido de cada um, do jeito que fez sentido pra mim.
Se em algum momento ficar confuso, não tem problema, dá uma olhada no livro que é sucesso&amp;nbsp;🫂💖&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Logaritmos:&lt;/h2&gt;
&lt;p&gt;O número máximo de tentativas na busca binária é dado por log₂(n), logaritmo na base 2 de&amp;nbsp;n.&lt;/p&gt;
&lt;p&gt;Se o nome assusta, pensa&amp;nbsp;assim:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;log₂(n) é o número de vezes que você precisa dividir n por 2 até chegar em&amp;nbsp;1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exemplo&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;log₂(128) = 7, 7 cortes ao meio até sobrar 1&amp;nbsp;item&lt;/li&gt;
&lt;li&gt;log₂(256) = 8, só mais uma etapa, mesmo dobrando o tamanho da&amp;nbsp;lista&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A base &amp;#8220;2&amp;#8221; vem justamente porque a cada passo cortamos a lista &lt;strong&gt;pela metade&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Tempo de&amp;nbsp;execução:&lt;/h2&gt;
&lt;p&gt;Sempre que falamos sobre um algoritmo, é importante pensar no tempo de execução, quanto esforço (ou quantos passos) ele precisa para chegar ao&amp;nbsp;resultado.&lt;/p&gt;
&lt;p&gt;Na &lt;strong&gt;busca linear&lt;/strong&gt; (a pesquisa simples), verificamos item por&amp;nbsp;item:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lista com 100 números → até 100&amp;nbsp;tentativas&lt;/li&gt;
&lt;li&gt;Lista com 4 bilhões de números → até 4 bilhões de&amp;nbsp;tentativas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O tempo de execução cresce na mesma proporção que o tamanho da lista. Chamamos isso de &lt;strong&gt;tempo linear&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;busca binária&lt;/strong&gt; é um outro&amp;nbsp;mundo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lista com 100 números → no máximo 7&amp;nbsp;tentativas&lt;/li&gt;
&lt;li&gt;Lista com 4 bilhões → no máximo 32&amp;nbsp;tentativas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Isso acontece porque a busca binária corta as possibilidades pela metade a cada passo. Esse tipo de crescimento é chamado de &lt;strong&gt;tempo logarítmico&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/image-4.png" alt="tempo de execução" width="400"/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Notação Big&amp;nbsp;O&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;notação Big O&lt;/strong&gt; é um jeito de medir a eficiência de um algoritmo, mostrando como o &lt;strong&gt;tempo de execução&lt;/strong&gt; cresce conforme aumentamos o tamanho da&amp;nbsp;entrada.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O(log n), tempo logarítmico (ex: pesquisa&amp;nbsp;binária)&lt;/li&gt;
&lt;li&gt;O(n), tempo linear (ex: pesquisa&amp;nbsp;simples)&lt;/li&gt;
&lt;li&gt;O(n * log n), um algoritmo rápido de ordenação, como quicksort (Capítulo&amp;nbsp;4)&lt;/li&gt;
&lt;li&gt;O(n²), um algoritmo de ordenação mais lenta, como ordenação por seleção (Capítulo&amp;nbsp;2).&lt;/li&gt;
&lt;li&gt;O(n!), um algoritmo extremamente lento, como o do caixeiro viajante (Capítulo&amp;nbsp;1).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O livro ilustra isso de forma bem visual e intuitiva: cresce linearmente, cresce em log, cresce muito, cresce lento&amp;#8230; e por aí&amp;nbsp;vai. &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Agora que vimos como a busca binária funciona, vale notar que ela não está restrita a livros, ela aparece em várias situações do nosso dia a&amp;nbsp;dia&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sistemas de busca (Google, WhatsApp, Spotify)&lt;/strong&gt;: por trás, usam variações de busca binária em listas ordenadas ou&amp;nbsp;índices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filtragem de dados&lt;/strong&gt;: encontrar rapidamente um registro específico em planilhas ou bases de dados&amp;nbsp;grandes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Depuração de código&lt;/strong&gt;: reduzir o espaço do problema pela metade a cada teste para achar onde o bug&amp;nbsp;está.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Observação&lt;/strong&gt;: para que a busca binária funcione, os dados precisam estar&amp;nbsp;ordenados.&lt;/p&gt;
&lt;h2&gt;Vamos praticar&amp;nbsp;rapidinho?&lt;/h2&gt;
&lt;p&gt;Aqui está uma lista ordenada de&amp;nbsp;números: &lt;code&gt;[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Tente encontrar o número 22 de duas&amp;nbsp;formas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Busca linear:&lt;/strong&gt; Vá um a um desde o&amp;nbsp;2.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Busca binária:&lt;/strong&gt; Comece no meio, elimine metade a cada&amp;nbsp;passo.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Compare quantos passos cada método&amp;nbsp;precisou&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Curiosidades&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;O git tem uma funcionalidade chamada &lt;a href="https://git-scm.com/docs/git-bisect"&gt;&lt;code&gt;git bisect&lt;/code&gt;&lt;/a&gt; que usa busca binária para ajudar desenvolvedores a encontrarem&amp;nbsp;bug&lt;/li&gt;
&lt;li&gt;Se o item que estamos buscando for o primeiro item da lista, esse é o melhor caso na busca linear e o pior caso na busca&amp;nbsp;binária&lt;/li&gt;
&lt;li&gt;A implementação&amp;nbsp;do &lt;code&gt;sortedcontainers&lt;/code&gt; usa busca binária (a partir do módulo bisect), &lt;a href="https://grantjenks.com/docs/sortedcontainers/_modules/sortedcontainers/sortedlist.html#SortedList"&gt;veja&amp;nbsp;aqui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Exercícios recomendados&amp;nbsp;👩🏻‍💻💞&lt;/h2&gt;
&lt;p&gt;Para reforçar o aprendizado, aqui vão alguns desafios&amp;nbsp;práticos:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/binary-search/description/"&gt;Binary Search&lt;/a&gt; — implementação&amp;nbsp;direta.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/search-insert-position/description/"&gt;Search Insert Position&lt;/a&gt; — variação para encontrar onde inserir um&amp;nbsp;número.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/first-bad-version/description/"&gt;First Bad Version&lt;/a&gt; — busca binária aplicada em &lt;span class="caps"&gt;API&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercism&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/exercises/binary-search"&gt;Binary Search (Python Track)&lt;/a&gt; — implementação e&amp;nbsp;testes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Dica: resolva primeiro o problema sem olhar a solução e depois compare com implementações&amp;nbsp;otimizadas.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;E assim começa meu roadmap de estudo: cada capítulo do livro vem acompanhado de exercícios para fixar o&amp;nbsp;conteúdo.&lt;/p&gt;</content><category term="Entendendo algoritmos"/></entry></feed>