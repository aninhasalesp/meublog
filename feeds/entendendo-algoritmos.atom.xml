<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>@aninhasalesp - Entendendo algoritmos</title><link href="/" rel="alternate"/><link href="/feeds/entendendo-algoritmos.atom.xml" rel="self"/><id>/</id><updated>2025-09-17T00:00:00-03:00</updated><entry><title>Explorando o livro â€œEntendendo Algoritmosâ€,Â cap.3</title><link href="/2025/09/17/explorando-o-livro-entendendo-algoritmos-cap3/" rel="alternate"/><published>2025-09-17T00:00:00-03:00</published><updated>2025-09-17T00:00:00-03:00</updated><author><name>Ana Paula Sales</name></author><id>tag:None,2025-09-17:/2025/09/17/explorando-o-livro-entendendo-algoritmos-cap3/</id><summary type="html">&lt;p&gt;AnÃ¡lises e exercÃ­cios prÃ¡ticos sobre o CapÃ­tulo 3 do livro &amp;#8220;Entendendo Algoritmos&amp;#8221;, com sugestÃµes de&amp;nbsp;desafios.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Terceiro capÃ­tulo da sÃ©rie de estudos sobre o livro &lt;a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf"&gt;Entendendo Algoritmos&lt;/a&gt; de Aditya Y.&amp;nbsp;Bhargava.&lt;/p&gt;
&lt;p&gt;Se vocÃª estÃ¡ acompanhando a sÃ©rie, jÃ¡ resumi os capÃ­tulos anteriores ğŸ‘€, entÃ£o volta lÃ¡ se tu tiver alguma dÃºvida:&lt;br&gt;
- &lt;a href="https://anapaula.org/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/"&gt;CapÃ­tulo 1 - IntroduÃ§Ã£o a algoritmos&lt;/a&gt;&lt;br&gt;
- &lt;a href="https://anapaula.org/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/"&gt;CapÃ­tulo 2 - OrdenaÃ§Ã£o por&amp;nbsp;seleÃ§Ã£o&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Oi, pessoal! Mais um resuminho do nosso livro querido&amp;nbsp;ğŸ˜Š &lt;/p&gt;
&lt;p&gt;Esse capÃ­tulo foi um dos que mais me tirou a sensaÃ§Ã£o de que programaÃ§Ã£o Ã© mÃ¡gica. Bora entender recursÃ£o e pilhas sem&amp;nbsp;medo?&lt;/p&gt;
&lt;p&gt;Neste capÃ­tulo, o autor explica de forma simples o conceito e o uso da &lt;strong&gt;recursÃ£o&lt;/strong&gt;, dividindo a explicaÃ§Ã£o em caso base e caso recursivo. 
Ele sugere que vocÃª, ao menos uma vez, analise uma funÃ§Ã£o recursiva com papel e caneta, acompanhando passo a passo, assim vocÃª entenderÃ¡ como a funÃ§Ã£o&amp;nbsp;funciona.&lt;/p&gt;
&lt;h1&gt;RecursÃ£o&lt;/h1&gt;
&lt;p&gt;Ã‰ a tÃ©cnica onde uma funÃ§Ã£o chama a si mesma para resolver um problema, dividindo-o em problemas menores. Devido ao fato de uma funÃ§Ã£o recursiva chamar a si mesma, Ã© mais fÃ¡cil de escrevÃª-la de forma errada e acabar em um loop infinito. Para que a recursÃ£o funcione corretamente, ela deve conter um caso base para parar as chamadas e um caso recursivo que aproxime o problema da soluÃ§Ã£o&amp;nbsp;final. &lt;/p&gt;
&lt;h2&gt;Como a recursÃ£o&amp;nbsp;funciona:&lt;/h2&gt;
&lt;p&gt;Antes de mostrar um exemplo de recursÃ£o, vamos entender como ela&amp;nbsp;funciona.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Caso base&lt;/strong&gt;: define quando a funÃ§Ã£o deve &lt;strong&gt;parar&lt;/strong&gt; de se chamar. Sem ele, a recursÃ£o continuaria indefinidamente, causando&amp;nbsp;erro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Caso recursivo&lt;/strong&gt;: Ã© a parte em que a funÃ§Ã£o &lt;strong&gt;se chama novamente&lt;/strong&gt;, aproximando-se da soluÃ§Ã£o final a cada&amp;nbsp;passo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Um exemplo clÃ¡ssico Ã© o cÃ¡lculo do fatorial de um&amp;nbsp;nÃºmero::&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fatorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;# Caso Base&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;# Caso Recursivo&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fatorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fatorial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;# SaÃ­da: 120&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Nesse&amp;nbsp;exemplo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Caso Base&lt;/strong&gt;: &lt;code&gt;n&lt;/code&gt; Ã© 0 ou 1, o fatorial Ã©&amp;nbsp;1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Caso Recursivo&lt;/strong&gt;:&amp;nbsp;Se &lt;code&gt;n&lt;/code&gt; Ã© maior que 1, o fatorial&amp;nbsp;Ã© &lt;code&gt;n * fatorial(n-1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Olha como fica quase poÃ©tico, cada nÃºmero chama o prÃ³ximo atÃ© o 1 dizer &amp;#8220;chega, agora volta&amp;#8221;. AÃ­ a multiplicaÃ§Ã£o acontece no caminho de&amp;nbsp;volta.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Pilha&lt;/h1&gt;
&lt;p&gt;Suponha que vocÃª esteja fazendo um churrasco para os seus amigos. VocÃª tem uma lista de afazeres em forma de uma pilha de notas adesivas. Quando vocÃª insere um item, ele Ã© colocado no topo da pilha. Quando vocÃª lÃª um item, lÃª apenas o item do topo da pilha e ele Ã© retirado da lista. Logo, sua lista de afazeres contÃ©m apenas duas aÃ§Ãµes: &lt;em&gt;push&lt;/em&gt; (inserir) e &lt;em&gt;pop&lt;/em&gt; (remover e&amp;nbsp;ler).&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/pilha.png" alt="pilha" width="700"/&gt;&lt;/p&gt;
&lt;p&gt;Esta estrutura de dados Ã© chamada de pilha. A pilha Ã© uma estrutura de dados simples e nÃ³s usamos o tempo todo sem&amp;nbsp;perceber.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Pilha de&amp;nbsp;chamadas&lt;/h1&gt;
&lt;p&gt;Sempre que uma funÃ§Ã£o Ã© chamada, o computador precisa â€œlembrarâ€ de onde ela parou para poder continuar depois.
Essa memÃ³ria temporÃ¡ria Ã© organizada numa &lt;strong&gt;pilha de chamadas&lt;/strong&gt; (call&amp;nbsp;stack).&lt;/p&gt;
&lt;p&gt;Funciona&amp;nbsp;assim:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A cada nova chamada de funÃ§Ã£o, o computador empilha informaÃ§Ãµes sobre essa execuÃ§Ã£o (como parÃ¢metros e variÃ¡veis&amp;nbsp;locais).&lt;/li&gt;
&lt;li&gt;Quando a funÃ§Ã£o termina, o computador desempilha esses dados e volta para o ponto&amp;nbsp;anterior.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A metÃ¡fora do livro Ã© Ã³tima, pense em uma pilha de pratos na cozinha. VocÃª sÃ³ consegue pegar (ou retirar) o prato que estÃ¡ por cima.  Assim tambÃ©m funciona com funÃ§Ãµes, o Ãºltimo que entrou Ã© o primeiro que sai (&lt;span class="caps"&gt;LIFO&lt;/span&gt;: Last In, First&amp;nbsp;Out).&lt;/p&gt;
&lt;p&gt;Podemos visualizar isso com um exemplo simples em&amp;nbsp;Python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cumprimenta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nome&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Oi,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nome&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;despedida&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;despedida&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Tchau!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;cumprimenta&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Ana&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ordem de execuÃ§Ã£o na&amp;nbsp;pilha:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cumprimenta(&amp;#8220;Ana&amp;#8221;) Ã© chamada â†’ vai para a&amp;nbsp;pilha.&lt;/li&gt;
&lt;li&gt;Dentro dela, despedida() Ã© chamada â†’ fica no&amp;nbsp;topo.&lt;/li&gt;
&lt;li&gt;despedida() roda e sai da&amp;nbsp;pilha.&lt;/li&gt;
&lt;li&gt;cumprimenta(&amp;#8220;Ana&amp;#8221;) roda atÃ© o fim e sai da&amp;nbsp;pilha.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ou seja, tudo organizado, prato por&amp;nbsp;prato.&lt;/p&gt;
&lt;p&gt;Esse exemplo jÃ¡ mostra que nÃ£o Ã© sÃ³ recursÃ£o que usa pilha, mas qualquer funÃ§Ã£o. A diferenÃ§a Ã© que a recursÃ£o forÃ§a a pilha a crescer muito mais&amp;nbsp;rÃ¡pido.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Pilha de chamadas com&amp;nbsp;recursÃ£o&lt;/h1&gt;
&lt;p&gt;Com recursÃ£o, essa pilha pode crescer bastante, porque a funÃ§Ã£o vai se chamando vÃ¡rias vezes atÃ© chegar no caso&amp;nbsp;base.&lt;/p&gt;
&lt;p&gt;Exemplo simplificado&amp;nbsp;com &lt;code&gt;fatorial(3)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;O programa chama fatorial(3)
    &lt;span class="k"&gt;-&lt;/span&gt; empilha fatorial(3)

Para resolver, precisa de fatorial(2)
    &lt;span class="k"&gt;-&lt;/span&gt; empilha fatorial(2)

Para resolver, precisa de fatorial(1)
    &lt;span class="k"&gt;-&lt;/span&gt; empilha fatorial(1)

fatorial(1) chega no caso base e retorna 1
    &lt;span class="k"&gt;-&lt;/span&gt; desempilha fatorial(1)

Agora fatorial(2) consegue calcular 2 Ã— 1 = 2
    &lt;span class="k"&gt;-&lt;/span&gt; desempilha fatorial(2)

Por fim, fatorial(3) calcula 3 Ã— 2 = 6
    &lt;span class="k"&gt;-&lt;/span&gt; desempilha fatorial(3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;No fim, cada chamada sÃ³ consegue terminar depois que a chamada menor retorna. 
Ã‰ por isso que &lt;strong&gt;definir bem o caso base Ã© tÃ£o importante&lt;/strong&gt;, sem ele, a funÃ§Ã£o nunca para de empilhar chamadas e acaba estourando a memÃ³ria (stack&amp;nbsp;overflow).&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/coffee.gif" alt="overflow" width="400"/&gt;&lt;/p&gt;
&lt;p&gt;Esse â€œestouro da pilhaâ€ Ã© justamente de onde veio o nome do site &lt;a href="https://stackoverflow.com/questions"&gt;Stack Overflow&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Quando vi esse processo pela primeira vez, parecia uma espÃ©cie de â€œmÃ¡gicaâ€, como se o computador simplesmente soubesse de onde&amp;nbsp;voltar.&lt;/p&gt;
&lt;p&gt;Foi nesse momento que percebi que entender programaÃ§Ã£o Ã© muito sobre desmistificar. NÃ£o Ã© dom, nÃ£o Ã© gÃªnio, Ã© sÃ³ empilhar e desempilhar com calma. 
Hoje, sempre que vejo um cÃ³digo recursivo, tento imaginar essa pilha acontecendo em segundo plano, isso traz clareza e ainda transforma o â€œeu nÃ£o nasci pra isso/nunca vou entender issoâ€ para um â€œhihi que legalâ€&amp;nbsp;ğŸ˜&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/chihuahua.gif" alt="cachorro" width="200"/&gt;&lt;/p&gt;
&lt;p&gt;EntÃ£o, da prÃ³xima vez que vocÃª se perder num cÃ³digo recursivo, respira: desenha a pilha, segue os passos, e lembra que nÃ£o Ã© mÃ¡gica, Ã© sÃ³ &lt;strong&gt;prÃ¡tica&lt;/strong&gt;!!!&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Curiosidades&amp;nbsp;ğŸ’¡&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Uma recursÃ£o muito comum fora da programaÃ§Ã£o: bonecas russas (matryoshkas). Cada boneca guarda outra dentro, atÃ© que a Ãºltima (caso base) nÃ£o guarda mais&amp;nbsp;nenhuma.&lt;/li&gt;
&lt;li&gt;Algumas linguagens aplicam otimizaÃ§Ã£o de recursÃ£o de cauda (tail call optimization), que reaproveita os quadros da pilha para nÃ£o estourar a memÃ³ria em funÃ§Ãµes recursivas muito profundas. Python, porÃ©m, nÃ£o faz&amp;nbsp;isso.&lt;/li&gt;
&lt;li&gt;A pilha de chamadas Ã© invisÃ­vel na maior parte do tempo, mas vocÃª jÃ¡ viu ela funcionando, quando o Python mostra um traceback (aquele erro cheio de setas, indicando em que funÃ§Ã£o a execuÃ§Ã£o&amp;nbsp;estava).&lt;/li&gt;
&lt;li&gt;Muitas funÃ§Ãµes recursivas podem ser reescritas de forma iterativa (usando&amp;nbsp;laÃ§os &lt;code&gt;for&lt;/code&gt; ou &lt;code&gt;while&lt;/code&gt;). Isso evita o risco de estouro da pilha em casos de chamadas muito&amp;nbsp;profundas.&lt;/li&gt;
&lt;li&gt;Para entender recursÃ£o, vocÃª precisa primeiro entender recursÃ£o.&amp;nbsp;ğŸ˜…&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2&gt;ExercÃ­cios recomendados&amp;nbsp;ğŸ‘©ğŸ»â€ğŸ’»ğŸ’&lt;/h2&gt;
&lt;p&gt;Para reforÃ§ar o aprendizado, aqui vÃ£o alguns desafios&amp;nbsp;prÃ¡ticos:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/merge-two-sorted-lists/description/"&gt;Merge two sorted lists&lt;/a&gt; - DÃ¡ pra resolver recursivamente, tratando como o caso base quando uma lista chega ao&amp;nbsp;fim.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/climbing-stairs/description/"&gt;Climbing Stairs&lt;/a&gt; - Um problema clÃ¡ssico de recursÃ£o + otimizaÃ§Ã£o (parecido com&amp;nbsp;Fibonacci).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercism&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/exercises/flatten-array"&gt;Flatten Array&lt;/a&gt; - Recebe uma lista que pode conter sublistas e precisa retornar tudo â€œachatadoâ€ em uma Ãºnica&amp;nbsp;lista&lt;/li&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/concepts/recursion"&gt;RecursÃ£o com Python&lt;/a&gt; - ReforÃ§a o conceito de recursÃ£o e tem o exercÃ­cio â€œLuhnâ€ que admite uma abordagem&amp;nbsp;recursiva&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Desafio&amp;nbsp;extra&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Crie uma funÃ§Ã£o recursiva que percorre pastas e arquivos no seu computador (ou sÃ³ numa lista aninhada simulada). Isso Ã© literalmente como muitos sistemas de arquivos&amp;nbsp;funcionam.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Espero que tenha aproveitado o conteÃºdo!&amp;nbsp;âœ¨ğŸ’•&lt;/p&gt;
&lt;p&gt;Se tiver alguma sugestÃ£o de exercÃ­cio ou melhoria na explicaÃ§Ã£o, me conta aqui&amp;nbsp;ğŸ«‚ğŸŒ»&lt;/p&gt;</content><category term="Entendendo algoritmos"/></entry><entry><title>Explorando o livro â€œEntendendo Algoritmosâ€,Â cap.2</title><link href="/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/" rel="alternate"/><published>2025-08-27T00:00:00-03:00</published><updated>2025-08-27T00:00:00-03:00</updated><author><name>Ana Paula Sales</name></author><id>tag:None,2025-08-27:/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/</id><summary type="html">&lt;p&gt;AnÃ¡lises e exercÃ­cios prÃ¡ticos sobre o CapÃ­tulo 2 do livro &amp;#8220;Entendendo Algoritmos&amp;#8221;, com sugestÃµes de&amp;nbsp;desafios.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Segundo capÃ­tulo da sÃ©rie de estudos sobre o livro &lt;a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf"&gt;Entendendo Algoritmos&lt;/a&gt; de Aditya Y.&amp;nbsp;Bhargava.&lt;/p&gt;
&lt;p&gt;Espero que vocÃªs tenham gostado da forma como estruturei o &lt;a href="https://anapaula.org/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/"&gt;primeiro capÃ­tulo&lt;/a&gt;, seguirei naquela mesma linha de raciocÃ­nio e explicaÃ§Ã£o. Se vocÃª tiver alguma sugestÃ£o de exercÃ­cio ou melhoria na explicaÃ§Ã£o, me conta aqui que eu ficarei feliz em receber esse feedback&amp;nbsp;ğŸ«‚ğŸ’•&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;No capÃ­tulo 2, o autor aprofunda dois conceitos fundamentais: &lt;strong&gt;estruturas de dados&lt;/strong&gt; (como arrays e listas) e a &lt;strong&gt;eficiÃªncia dos algoritmos&lt;/strong&gt; (notaÃ§Ã£o Big O). Para ilustrar isso, ele apresenta o algoritmo de &lt;strong&gt;ordenaÃ§Ã£o por seleÃ§Ã£o&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Arrays e&amp;nbsp;Listas&lt;/h1&gt;
&lt;p&gt;Antes de falar em ordenaÃ§Ã£o, Ã© importante entender como os dados podem ser armazenados na memÃ³ria.&amp;nbsp;ğŸ‘€&lt;/p&gt;
&lt;p&gt;O autor traz uma analogia que faz o entendimento ficar muuuito mais fÃ¡cil. Em resumo, a ideia Ã© algo&amp;nbsp;assim:&lt;/p&gt;
&lt;p&gt;Imagine que vocÃª vai a um show e precisa guardar suas coisas na chapelaria (eu nem sabia que isso existia ğŸ¤”). Apenas algumas gavetas estÃ£o disponÃ­veis e vocÃª pode guardar um item por gaveta. VocÃª pega e guarda suas coisas nessas gavetas, fecha, e estÃ¡ pronto para ir ao&amp;nbsp;show.&lt;/p&gt;
&lt;p&gt;A memÃ³ria do computador funciona mais ou menos assim. O computador parece um grande conjunto de gavetas, e cada gaveta tem um endereÃ§o. Cada vez que tu armazena um item na memÃ³ria, o computador fornece um endereÃ§o para guardar esse&amp;nbsp;item.&lt;/p&gt;
&lt;p&gt;E aÃ­, se tu quiser armazenar mÃºltiplos itens, existem duas maneiras principais de fazer isso: &lt;strong&gt;arrays&lt;/strong&gt; e &lt;strong&gt;listas&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Arrays&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SÃ£o blocos contÃ­guos de memÃ³ria (um ao lado do&amp;nbsp;outro).&lt;/li&gt;
&lt;li&gt;Cada elemento pode ser acessado &lt;strong&gt;diretamente&lt;/strong&gt; pelo Ã­ndice, permitindo uma leitura rÃ¡pida.&lt;ul&gt;
&lt;li&gt;Isso significa que a operaÃ§Ã£o de busca por posiÃ§Ã£o Ã© O(1), ou seja,&amp;nbsp;constante.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  &lt;span class="c1"&gt;# acesso direto ao 20&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;O lado ruim do array Ã© que, se tu quiser adicionar mais um item e a gaveta seguinte estiver ocupada, serÃ¡ necessÃ¡rio solicitar ao computador uma Ã¡rea de memÃ³ria maior para armazenar todos os itens e mover os existentes para&amp;nbsp;lÃ¡.&lt;/li&gt;
&lt;li&gt;EntÃ£o adicionar novos itens a um array Ã© algo que pode ser muito&amp;nbsp;lento.&lt;/li&gt;
&lt;li&gt;Deletar um elemento Ã© tÃ£o custoso quanto adicionar, todos os elementos seguintes precisam ser&amp;nbsp;movidos.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Listas&amp;nbsp;encadeadas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Seus itens podem estar &lt;strong&gt;em qualquer lugar da memÃ³ria&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Cada item armazena o endereÃ§o do prÃ³ximo item da&amp;nbsp;lista.&lt;/li&gt;
&lt;li&gt;Semelhante a uma caÃ§a ao tesouro, cada pista encontrada indica onde estÃ¡ a prÃ³xima&amp;nbsp;etapa.&lt;/li&gt;
&lt;li&gt;Adicionar um item Ã© simples, vocÃª coloca o item em qualquer lugar da memÃ³ria e atualiza o endereÃ§o do item&amp;nbsp;anterior.&lt;/li&gt;
&lt;li&gt;Para deletar, Ã© tÃ£o simples quanto, basta alterar o endereÃ§o do item anterior para apontar para o prÃ³ximo&amp;nbsp;item.&lt;/li&gt;
&lt;li&gt;O lado ruim da lista encadeada Ã© que, para acessar um elemento especÃ­fico (por exemplo, o Ãºltimo), vocÃª nÃ£o pode ir direto, precisa percorrer a lista &lt;strong&gt;item por item&lt;/strong&gt; atÃ© chegar&amp;nbsp;lÃ¡.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;valor&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
          &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;valor&lt;/span&gt;
          &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proximo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

  &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proximo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

  &lt;span class="c1"&gt;# Percorrendo&lt;/span&gt;
  &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proximo&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Explicando o cÃ³digo acima:
1. Crio a&amp;nbsp;classe &lt;code&gt;Node&lt;/code&gt;, que armazena um valor&amp;nbsp;(&lt;code&gt;valor&lt;/code&gt;) e um ponteiro para o prÃ³ximo nÃ³&amp;nbsp;(&lt;code&gt;proximo&lt;/code&gt;).
2. Crio dois&amp;nbsp;nÃ³s: &lt;code&gt;a&lt;/code&gt; com valor 10&amp;nbsp;e &lt;code&gt;b&lt;/code&gt; com valor 20.
3.&amp;nbsp;Ligo &lt;code&gt;a&lt;/code&gt; ao &lt;code&gt;b&lt;/code&gt; com &lt;code&gt;a.proximo = b&lt;/code&gt;.
4. Percorro a lista&amp;nbsp;com &lt;code&gt;while n:&lt;/code&gt; imprimindo &lt;code&gt;n.valor&lt;/code&gt; atÃ© chegar no final&amp;nbsp;(&lt;code&gt;None&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;A saÃ­da pra esse&amp;nbsp;cÃ³digo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="mi"&gt;20&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;p&gt;NÃ£o sei vocÃªs, mas &lt;strong&gt;entender a diferenÃ§a entre arrays e listas&lt;/strong&gt; foi um verdadeiro estalo para mim. Como aprendi Python primeiro, eu meio que usava essas estruturas no automÃ¡ticoâ€¦ ğŸ¥² 
Pode parecer algo Ã³bvio ou atÃ© desnecessÃ¡rio, afinal, lidamos com arrays e listas o tempo todo, mas foi incrÃ­vel compreender &lt;strong&gt;por que as coisas funcionam do jeito que funcionam&lt;/strong&gt;. Minha cabeÃ§a finalmente comeÃ§ou a encaixar as peÃ§as e perceber a lÃ³gica por trÃ¡s das operaÃ§Ãµes. Fiquei meio&amp;nbsp;que:&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/cat-in-shock-surprises.gif" alt="gato surpreso" width="150"/&gt;&lt;/p&gt;
&lt;p&gt;Aqui estÃ£o os tempos de execuÃ§Ã£o para as operaÃ§Ãµes mais comuns em arrays e listas&amp;nbsp;encadeadas&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/array_lista.png" alt="tempo de execuÃ§Ã£o" width="400"/&gt;&lt;/p&gt;
&lt;p&gt;Acho importante trazer essa tabela, para que o entendimento sobre notaÃ§Ã£o Big O se consolide e pra todos entenderem o impacto das nossas escolhas em diferentes&amp;nbsp;situaÃ§Ãµes.&lt;/p&gt;
&lt;p&gt;A interpretaÃ§Ã£o pra essa tabela de uma forma mais explÃ­cita&amp;nbsp;seria:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Leitura&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Array â†’ O(1)&lt;/strong&gt;:
    Em um array, cada posiÃ§Ã£o tem um endereÃ§o fixo na memÃ³ria. EntÃ£o, se vocÃª quiser o 5Âº elemento, o computador vai direto nele de uma forma super rÃ¡pida e em tempo&amp;nbsp;constante.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lista â†’ O(n)&lt;/strong&gt;:
    uma lista encadeada, cada elemento sabe apenas quem Ã© o prÃ³ximo. EntÃ£o, para achar o 5Âº elemento, vocÃª precisa comeÃ§ar do 1Âº, depois o 2Âº, depois o 3Âºâ€¦ atÃ© chegar no 5Âº. Quanto maior a lista, mais tempo&amp;nbsp;demora.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;InserÃ§Ã£o&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Array â†’ O(n)&lt;/strong&gt;:
    Se o array estiver cheio e vocÃª quiser enfiar um novo item no meio, tem que â€œempurrarâ€ todos os outros elementos uma posiÃ§Ã£o para frente. Isso pode levar bastante&amp;nbsp;tempo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lista â†’ O(1)&lt;/strong&gt;:
    Se vocÃª jÃ¡ sabe a posiÃ§Ã£o, inserir numa lista Ã© rapidinho, basta mudar quem aponta pra quem e&amp;nbsp;pronto.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DeleÃ§Ã£o&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Array â†’ O(n)&lt;/strong&gt;:
    Se vocÃª remove um item no meio do array, precisa â€œpuxarâ€ todos os elementos da frente uma posiÃ§Ã£o pra trÃ¡s para fechar o&amp;nbsp;buraco.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lista â†’ O(1)&lt;/strong&gt;:
    Assim como na inserÃ§Ã£o, basta mudar os ponteiros para pular o item que vocÃª quer remover. NÃ£o mexe em mais&amp;nbsp;ninguÃ©m.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1&gt;OrdenaÃ§Ã£o por&amp;nbsp;seleÃ§Ã£o&lt;/h1&gt;
&lt;p&gt;O autor apresenta o algoritmo Selection Sort, que Ã© simples de implementar, mas nÃ£o muito eficiente.
A diferenÃ§a entre arrays e listas em Python torna importante entender como o algoritmo percorre e manipula os&amp;nbsp;elementos.&lt;/p&gt;
&lt;h3&gt;Ideia do&amp;nbsp;algoritmo&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar o menor elemento da&amp;nbsp;lista&lt;/li&gt;
&lt;li&gt;ColocÃ¡-lo na primeira&amp;nbsp;posiÃ§Ã£o&lt;/li&gt;
&lt;li&gt;Repetir para as posiÃ§Ãµes seguintes atÃ© ordenar toda a&amp;nbsp;lista&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;ImplementaÃ§Ã£o em&amp;nbsp;Python:&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;busca_menor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Encontra o Ã­ndice do menor elemento em um array.&lt;/span&gt;

&lt;span class="sd"&gt;    ParÃ¢metros:&lt;/span&gt;
&lt;span class="sd"&gt;    arr (list): Lista de elementos comparÃ¡veis.&lt;/span&gt;

&lt;span class="sd"&gt;    Retorna:&lt;/span&gt;
&lt;span class="sd"&gt;    int: Ãndice do menor elemento encontrado.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;menor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;menor_indice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;menor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;menor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;menor_indice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;menor_indice&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ordenacao_por_selecao&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    Ordena uma lista usando o algoritmo de ordenaÃ§Ã£o por seleÃ§Ã£o.&lt;/span&gt;

&lt;span class="sd"&gt;    A funÃ§Ã£o cria uma nova lista, removendo o menor elemento&lt;/span&gt;
&lt;span class="sd"&gt;    da lista original a cada iteraÃ§Ã£o e adicionando-o Ã  lista ordenada.&lt;/span&gt;

&lt;span class="sd"&gt;    ParÃ¢metros:&lt;/span&gt;
&lt;span class="sd"&gt;    arr (list): Lista de nÃºmeros a serem ordenados.&lt;/span&gt;

&lt;span class="sd"&gt;    Retorna:&lt;/span&gt;
&lt;span class="sd"&gt;    list: Nova lista ordenada em ordem crescente.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;novo_arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="n"&gt;menor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;busca_menor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;novo_arr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;novo_arr&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ordenacao_por_selecao&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt; &lt;span class="c1"&gt;# SaÃ­da: [2, 3, 5, 6, 10]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;h3&gt;Complexidade e Big&amp;nbsp;O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;O selection sort precisa percorrer todos os elementos vÃ¡rias&amp;nbsp;vezes.&lt;/li&gt;
&lt;li&gt;Para n elementos, ele faz aproximadamente n Ã— n&amp;nbsp;operaÃ§Ãµes.&lt;/li&gt;
&lt;li&gt;Isso significa que seu desempenho Ã©&amp;nbsp;O(nÂ²).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Este Ã© um exemplo clÃ¡ssico que mostra como &lt;strong&gt;algoritmos diferentes podem resolver o mesmo problema com eficiÃªncias diferentes&lt;/strong&gt;, destacando a importÃ¢ncia de escolher o algoritmo certo dependendo do tamanho e da estrutura dos&amp;nbsp;dados.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Curiosidades&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;As listas em Python sÃ£o, na verdade, &lt;strong&gt;arrays&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;O&amp;nbsp;mÃ©todo &lt;code&gt;append&lt;/code&gt; (adicionar no final) Ã© considerado de complexidade &lt;strong&gt;O(1)&lt;/strong&gt; na mÃ©dia. Isso porque adicionar um item no final geralmente Ã© bem barato: sÃ³ colocar no prÃ³ximo espaÃ§o&amp;nbsp;livre.&lt;/li&gt;
&lt;li&gt;O â€œcusto altoâ€ aparece em operaÃ§Ãµes&amp;nbsp;como &lt;code&gt;insert&lt;/code&gt; ou &lt;code&gt;remove&lt;/code&gt; no meio da lista. AÃ­ Ã© preciso deslocar todos os elementos seguintes, o que pode ser &lt;strong&gt;O(n)&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Uma forma de visualizar: pense numa pilha de pratos. Colocar ou tirar um prato do topo&amp;nbsp;(como &lt;code&gt;append&lt;/code&gt; e &lt;code&gt;pop&lt;/code&gt;) Ã© fÃ¡cil. Mas se vocÃª quiser enfiar ou tirar um prato do meio da pilha&amp;nbsp;(&lt;code&gt;insert&lt;/code&gt; ou &lt;code&gt;remove&lt;/code&gt;), vai ter que mover todos os pratos que estavam em cima&amp;nbsp;primeiro.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;ExercÃ­cios recomendados&amp;nbsp;ğŸ‘©ğŸ»â€ğŸ’»ğŸ’&lt;/h2&gt;
&lt;p&gt;Para reforÃ§ar o aprendizado, aqui vÃ£o alguns desafios&amp;nbsp;prÃ¡ticos:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/two-sum/description/"&gt;Two Sum&lt;/a&gt; - clÃ¡ssico de&amp;nbsp;arrays&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/"&gt;Best Time to Buy and Sell Stock&lt;/a&gt; - Percorrer array com anÃ¡lise de&amp;nbsp;tempo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/merge-sorted-array/description/"&gt;Merge Sorted Array&lt;/a&gt; - ManipulaÃ§Ã£o de listas&amp;nbsp;ordenadas&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercism&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/exercises/isogram"&gt;Isogram&lt;/a&gt; - Percorre strings/arrays verificando&amp;nbsp;duplicatas&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;E assim, fechamos o segundo capÃ­tulo!
Espero que tenha sido Ãºtil e leve de ler&amp;nbsp;ğŸ’ğŸ»â€â™€ï¸âœ¨&lt;/p&gt;</content><category term="Entendendo algoritmos"/></entry><entry><title>Explorando o livro â€œEntendendo Algoritmosâ€,Â cap.1</title><link href="/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/" rel="alternate"/><published>2025-08-12T00:00:00-03:00</published><updated>2025-08-12T00:00:00-03:00</updated><author><name>Ana Paula Sales</name></author><id>tag:None,2025-08-12:/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/</id><summary type="html">&lt;p&gt;AnÃ¡lises e exercÃ­cios prÃ¡ticos sobre o CapÃ­tulo 1 do livro &amp;#8220;Entendendo Algoritmos&amp;#8221;, com sugestÃµes de&amp;nbsp;desafios.&lt;/p&gt;</summary><content type="html">&lt;p&gt;InÃ­cio de uma sÃ©rie de estudos sobre o livro &lt;a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf"&gt;Entendendo Algoritmos&lt;/a&gt; de Aditya Y.&amp;nbsp;Bhargava. &lt;/p&gt;
&lt;p&gt;Esse livro foi indicado por uma amiga, &lt;a href="https://github.com/anapaulamendes"&gt;Ana Paula Mendes&lt;/a&gt;, e eu nÃ£o imaginava o quanto iria gostar. A leitura Ã© leve, clara e muito acessÃ­vel. Se vocÃª, como eu, tem dificuldade em manter a constÃ¢ncia em leituras tÃ©cnicas, esse livro Ã© um achado, fÃ¡cil de entender, Ã³timo para aprender ou revisar&amp;nbsp;conceitos. &lt;/p&gt;
&lt;p&gt;Ele apresenta ideias da ciÃªncia da computaÃ§Ã£o que estÃ£o no nosso dia a dia, muitas vezes sem que a gente&amp;nbsp;perceba.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/livro1.jpg" alt="capa do livro" width="400"/&gt;&lt;/p&gt;
&lt;p&gt;Uma das coisas que mais me chamam atenÃ§Ã£o nesse livro Ã© o jeito como o autor ensina, sempre com exemplos. Em vez de encher de sÃ­mbolos e fÃ³rmulas, ele quer que a gente visualize os conceitos. Ele acredita, e eu concordo, que aprendemos melhor quando conseguimos relacionar o conteÃºdo com algo que jÃ¡ conhecemos. E, pra isso, os exemplos ajudam&amp;nbsp;muito. &lt;/p&gt;
&lt;p&gt;E o melhor Ã© que ele desenha ğŸ¤©! 
Sabe aquela frase â€œquer que eu desenhe pra vocÃª entenderâ€? Eu respondo â€œsim, por favorrrrr!â€ e ele realmente desenha. Ã‰ maravilhoso&amp;nbsp;âœ¨. &lt;/p&gt;
&lt;p&gt;DÃ¡ pra sentir que tudo foi pensado com cuidado, desde o conteÃºdo, os exemplos ilustrados atÃ© a recapitulaÃ§Ã£o no fim de cada&amp;nbsp;capÃ­tulo. &lt;/p&gt;
&lt;p&gt;Depois dessa introduÃ§Ã£o, bora ver o que o capÃ­tulo 1&amp;nbsp;ensina.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/hahahaha-gif.gif" alt="gif" width="100"/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;A busca binÃ¡ria em&amp;nbsp;resumo&lt;/h1&gt;
&lt;p&gt;Pensa numa lista telefÃ´nica com &lt;strong&gt;1 milhÃ£o de nomes&lt;/strong&gt;. Olhar folha por folha seria um pesadelo, nÃ©? 
Agora, e se eu te dissesse que dÃ¡ para encontrar qualquer nome em no &lt;strong&gt;mÃ¡ximo 20 tentativas&lt;/strong&gt;?&amp;nbsp;ğŸ‘€&lt;/p&gt;
&lt;p&gt;O truque Ã© simples: a cada etapa, tu elimina metade das opÃ§Ãµes. Comece considerando o elemento que estÃ¡ bem no meio da sequÃªncia. Em uma lista telefÃ´nica, isso seria abrir o livro bem no meio. Em uma lista com 10 itens, isso seria pegar o 5o item. Agora compare esse item do meio com o que vocÃª estÃ¡ buscando: se eles forem iguais, parabÃ©ns, vocÃª encontrou o que procurava! Agora, se o item que vocÃª encontrou for &lt;span class="caps"&gt;MAIOR&lt;/span&gt; que o item que vocÃª procura (no caso de nomes em uma lista telefÃ´nica, pense em qual nome vem primeiro na ordem alfabÃ©tica), quer dizer que o item buscado estÃ¡ na primeira metade da lista. Caso contrÃ¡rio, o item estÃ¡ na segunda metade da lista. E assim vocÃª consegue cortar a lista pela &lt;em&gt;metade&lt;/em&gt; apenas comparando o item procurado com o item do meio. Depois disso, basta pegar a parte que vocÃª selecionou e aplicar a mesma estratÃ©gia, checando o item do meio e descartando metade da lista.
&lt;strong&gt;ObservaÃ§Ã£o&lt;/strong&gt;: Essa tÃ©cnica sÃ³ funciona se a lista de itens estiver&amp;nbsp;ordenada!&lt;/p&gt;
&lt;p&gt;E o mais legal Ã© que, mesmo que a lista dobre de tamanho, tu sÃ³ precisa de &lt;strong&gt;mais uma&lt;/strong&gt; etapa para chegar ao resultado.&amp;nbsp;ğŸ¤“&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exemplo&lt;/strong&gt;:
Para facilitar a conta, vamos pegar uma lista menor de 128 nomes e calcular o nÃºmero mÃ¡ximo de etapas que levarÃ­amos para encontrar um nome especÃ­fico. Logo em seguida, dobramos o tamanho da lista e vemos que isso adiciona apenas mais uma&amp;nbsp;etapa:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;etapas&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;//=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="n"&gt;etapas&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;etapas&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# 7&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_etapas&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# 8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ObservaÃ§Ã£o importante&lt;/strong&gt;: numa lista telefÃ´nica fÃ­sica, a gente jÃ¡ sabe pular quase direto para a letra certa, o que lembra mais o funcionamento de um hashmap (ou dict no Python), que encontra um item em tempo constante. Mas no computador, quando temos apenas uma lista ordenada&amp;nbsp;(como &lt;code&gt;[1, 3, 5, 7, 9, 11, 13]&lt;/code&gt;), nÃ£o existe esse â€œpulo mÃ¡gicoâ€, Ã© aÃ­ que a busca binÃ¡ria pode ajudar, cortando a lista ao meio de forma sistemÃ¡tica atÃ© encontrar (ou concluir que o elemento nÃ£o estÃ¡&amp;nbsp;lÃ¡).&lt;/p&gt;
&lt;p&gt;Legal nÃ©? Isso Ã© ciÃªncia da computaÃ§Ã£o!!&amp;nbsp;ğŸ’â€â™€ï¸âœ¨&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Exemplos bÃ¡sicos de busca&amp;nbsp;binÃ¡ria:&lt;/h2&gt;
&lt;p&gt;Pense em um nÃºmero entre 1 e 100. DÃ¡ para adivinhar em, no mÃ¡ximo, 7&amp;nbsp;tentativas:&lt;/p&gt;
&lt;p&gt;Minha primeira pergunta: &amp;#8220;Ã‰&amp;nbsp;50?&amp;#8221;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se vocÃª disser &amp;#8220;maior&amp;#8221;, eu sei que estÃ¡ entre 51 e&amp;nbsp;100&lt;/li&gt;
&lt;li&gt;Se disser &amp;#8220;menor&amp;#8221;, estÃ¡ entre 1 e&amp;nbsp;49&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Segunda pergunta: Digamos que seja maior que 50. &amp;#8220;Ã‰ 75?&amp;#8221; (meio entre 51 e&amp;nbsp;100)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maior? EstÃ¡ entre 76 e&amp;nbsp;100&lt;/li&gt;
&lt;li&gt;Menor? EstÃ¡ entre 51 e&amp;nbsp;74&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E assim por diante, sempre eliminando metade das&amp;nbsp;possibilidades.&lt;/p&gt;
&lt;h3&gt;Vamos ver como fica com uma quantidade maior de&amp;nbsp;nÃºmeros:&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Itens na lista&lt;/th&gt;
&lt;th&gt;Busca linear (tentativas)&lt;/th&gt;
&lt;th&gt;Busca binÃ¡ria (tentativas)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.000&lt;/td&gt;
&lt;td&gt;atÃ© 1.000&lt;/td&gt;
&lt;td&gt;atÃ© 10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.000.000&lt;/td&gt;
&lt;td&gt;atÃ© 1.000.000&lt;/td&gt;
&lt;td&gt;atÃ© 20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Sim, 20 tentativas para encontrar algo entre 1 milhÃ£o de opÃ§Ãµes!&amp;nbsp;ğŸš€&lt;/p&gt;
&lt;p&gt;Esse â€œmilagreâ€ da busca binÃ¡ria acontece por causa de um conceito chamado &lt;strong&gt;logaritmo&lt;/strong&gt;, e jÃ¡ jÃ¡ eu te mostro o&amp;nbsp;porquÃª.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Agora que vocÃª jÃ¡ entendeu a busca binÃ¡ria, vamos entrar em mais trÃªs pontos que andam de mÃ£os dadas: &lt;strong&gt;logaritmos, tempo de execuÃ§Ã£o e notaÃ§Ã£o Big O&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Preparei um resumo rÃ¡pido de cada um, do jeito que fez sentido pra mim.
Se em algum momento ficar confuso, nÃ£o tem problema, dÃ¡ uma olhada no livro que Ã© sucesso&amp;nbsp;ğŸ«‚ğŸ’–&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Logaritmos:&lt;/h2&gt;
&lt;p&gt;O nÃºmero mÃ¡ximo de tentativas na busca binÃ¡ria Ã© dado por logâ‚‚(n), logaritmo na base 2 de&amp;nbsp;n.&lt;/p&gt;
&lt;p&gt;Se o nome assusta, pensa&amp;nbsp;assim:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;logâ‚‚(n) Ã© o nÃºmero de vezes que vocÃª precisa dividir n por 2 atÃ© chegar em&amp;nbsp;1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exemplo&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;logâ‚‚(128) = 7, 7 cortes ao meio atÃ© sobrar 1&amp;nbsp;item&lt;/li&gt;
&lt;li&gt;logâ‚‚(256) = 8, sÃ³ mais uma etapa, mesmo dobrando o tamanho da&amp;nbsp;lista&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A base &amp;#8220;2&amp;#8221; vem justamente porque a cada passo cortamos a lista &lt;strong&gt;pela metade&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Tempo de&amp;nbsp;execuÃ§Ã£o:&lt;/h2&gt;
&lt;p&gt;Sempre que falamos sobre um algoritmo, Ã© importante pensar no tempo de execuÃ§Ã£o, quanto esforÃ§o (ou quantos passos) ele precisa para chegar ao&amp;nbsp;resultado.&lt;/p&gt;
&lt;p&gt;Na &lt;strong&gt;busca linear&lt;/strong&gt; (a pesquisa simples), verificamos item por&amp;nbsp;item:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lista com 100 nÃºmeros â†’ atÃ© 100&amp;nbsp;tentativas&lt;/li&gt;
&lt;li&gt;Lista com 4 bilhÃµes de nÃºmeros â†’ atÃ© 4 bilhÃµes de&amp;nbsp;tentativas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O tempo de execuÃ§Ã£o cresce na mesma proporÃ§Ã£o que o tamanho da lista. Chamamos isso de &lt;strong&gt;tempo linear&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;busca binÃ¡ria&lt;/strong&gt; Ã© um outro&amp;nbsp;mundo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lista com 100 nÃºmeros â†’ no mÃ¡ximo 7&amp;nbsp;tentativas&lt;/li&gt;
&lt;li&gt;Lista com 4 bilhÃµes â†’ no mÃ¡ximo 32&amp;nbsp;tentativas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Isso acontece porque a busca binÃ¡ria corta as possibilidades pela metade a cada passo. Esse tipo de crescimento Ã© chamado de &lt;strong&gt;tempo logarÃ­tmico&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/image-4.png" alt="tempo de execuÃ§Ã£o" width="400"/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;NotaÃ§Ã£o Big&amp;nbsp;O&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;notaÃ§Ã£o Big O&lt;/strong&gt; Ã© um jeito de medir a eficiÃªncia de um algoritmo, mostrando como o &lt;strong&gt;tempo de execuÃ§Ã£o&lt;/strong&gt; cresce conforme aumentamos o tamanho da&amp;nbsp;entrada.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O(log n), tempo logarÃ­tmico (ex: pesquisa&amp;nbsp;binÃ¡ria)&lt;/li&gt;
&lt;li&gt;O(n), tempo linear (ex: pesquisa&amp;nbsp;simples)&lt;/li&gt;
&lt;li&gt;O(n * log n), um algoritmo rÃ¡pido de ordenaÃ§Ã£o, como quicksort (CapÃ­tulo&amp;nbsp;4)&lt;/li&gt;
&lt;li&gt;O(nÂ²), um algoritmo de ordenaÃ§Ã£o mais lenta, como ordenaÃ§Ã£o por seleÃ§Ã£o (CapÃ­tulo&amp;nbsp;2).&lt;/li&gt;
&lt;li&gt;O(n!), um algoritmo extremamente lento, como o do caixeiro viajante (CapÃ­tulo&amp;nbsp;1).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O livro ilustra isso de forma bem visual e intuitiva: cresce linearmente, cresce em log, cresce muito, cresce lento&amp;#8230; e por aÃ­&amp;nbsp;vai. &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Agora que vimos como a busca binÃ¡ria funciona, vale notar que ela nÃ£o estÃ¡ restrita a livros, ela aparece em vÃ¡rias situaÃ§Ãµes do nosso dia a&amp;nbsp;dia&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sistemas de busca (Google, WhatsApp, Spotify)&lt;/strong&gt;: por trÃ¡s, usam variaÃ§Ãµes de busca binÃ¡ria em listas ordenadas ou&amp;nbsp;Ã­ndices.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filtragem de dados&lt;/strong&gt;: encontrar rapidamente um registro especÃ­fico em planilhas ou bases de dados&amp;nbsp;grandes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DepuraÃ§Ã£o de cÃ³digo&lt;/strong&gt;: reduzir o espaÃ§o do problema pela metade a cada teste para achar onde o bug&amp;nbsp;estÃ¡.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ObservaÃ§Ã£o&lt;/strong&gt;: para que a busca binÃ¡ria funcione, os dados precisam estar&amp;nbsp;ordenados.&lt;/p&gt;
&lt;h2&gt;Vamos praticar&amp;nbsp;rapidinho?&lt;/h2&gt;
&lt;p&gt;Aqui estÃ¡ uma lista ordenada de&amp;nbsp;nÃºmeros: &lt;code&gt;[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Tente encontrar o nÃºmero 22 de duas&amp;nbsp;formas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Busca linear:&lt;/strong&gt; VÃ¡ um a um desde o&amp;nbsp;2.  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Busca binÃ¡ria:&lt;/strong&gt; Comece no meio, elimine metade a cada&amp;nbsp;passo.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Compare quantos passos cada mÃ©todo&amp;nbsp;precisou&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Curiosidades&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;O git tem uma funcionalidade chamada &lt;a href="https://git-scm.com/docs/git-bisect"&gt;&lt;code&gt;git bisect&lt;/code&gt;&lt;/a&gt; que usa busca binÃ¡ria para ajudar desenvolvedores a encontrarem&amp;nbsp;bug&lt;/li&gt;
&lt;li&gt;Se o item que estamos buscando for o primeiro item da lista, esse Ã© o melhor caso na busca linear e o pior caso na busca&amp;nbsp;binÃ¡ria&lt;/li&gt;
&lt;li&gt;A implementaÃ§Ã£o&amp;nbsp;do &lt;code&gt;sortedcontainers&lt;/code&gt; usa busca binÃ¡ria (a partir do mÃ³dulo bisect), &lt;a href="https://grantjenks.com/docs/sortedcontainers/_modules/sortedcontainers/sortedlist.html#SortedList"&gt;veja&amp;nbsp;aqui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;ExercÃ­cios recomendados&amp;nbsp;ğŸ‘©ğŸ»â€ğŸ’»ğŸ’&lt;/h2&gt;
&lt;p&gt;Para reforÃ§ar o aprendizado, aqui vÃ£o alguns desafios&amp;nbsp;prÃ¡ticos:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/binary-search/description/"&gt;Binary Search&lt;/a&gt; â€” implementaÃ§Ã£o&amp;nbsp;direta.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/search-insert-position/description/"&gt;Search Insert Position&lt;/a&gt; â€” variaÃ§Ã£o para encontrar onde inserir um&amp;nbsp;nÃºmero.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/first-bad-version/description/"&gt;First Bad Version&lt;/a&gt; â€” busca binÃ¡ria aplicada em &lt;span class="caps"&gt;API&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Exercism&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://exercism.org/tracks/python/exercises/binary-search"&gt;Binary Search (Python Track)&lt;/a&gt; â€” implementaÃ§Ã£o e&amp;nbsp;testes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Dica: resolva primeiro o problema sem olhar a soluÃ§Ã£o e depois compare com implementaÃ§Ãµes&amp;nbsp;otimizadas.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;E assim comeÃ§a meu roadmap de estudo: cada capÃ­tulo do livro vem acompanhado de exercÃ­cios para fixar o&amp;nbsp;conteÃºdo.&lt;/p&gt;</content><category term="Entendendo algoritmos"/></entry></feed>