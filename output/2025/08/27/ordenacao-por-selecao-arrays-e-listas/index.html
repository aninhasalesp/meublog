<!DOCTYPE html>
<html lang="en">
<head>
        <title>OrdenaÃ§Ã£o por SeleÃ§Ã£o, Arrays eÂ Listas</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
        <link href="/" type="application/atom+xml" rel="alternate" title="@aninhasalesp ATOM Feed" />
</head>

<body id="index" class="home" style="margin: auto;">
        <header id="banner" class="body">
                <h1><a href="/">@aninhasalesp </a></h1>
                <nav><ul>
                    <li ><a href="/pages/contato.html">Contato</a></li>
                    <li ><a href="/pages/sugestoes-de-leitura.html">SugestÃµes de&nbsp;leitura</a></li>
                    <li ><a href="/pages/quem-sou-eu.html">Quem sou eu?&nbsp;ğŸŒ¿ğŸŒ¸</a></li>
                <li><a href="/">Posts</a></li>
                </ul></nav>
        </header><!-- /#banner -->

<div style="display: flex; flex-direction: column;">
  <section id="content" class="body">
    <article>
      <header>
        <h1 class="entry-title">
          <a href="2025/08/27/ordenacao-por-selecao-arrays-e-listas/" rel="bookmark">
            OrdenaÃ§Ã£o por SeleÃ§Ã£o, Arrays e&nbsp;Listas
          </a>
        </h1>       </header>

      <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2025-08-27T00:00:00-03:00">
                qua 27 agosto 2025
        </abbr>

        <!-- <address class="vcard author">
                By <a class="url fn" href="/author/ana-paula-sales.html">Ana Paula Sales</a>
        </address> -->
<!-- <p>In <a href="/category/entendendo-algoritmos.html">Entendendo algoritmos</a>. </p> -->
</p></footer><!-- /.post-info --><!-- /.post-info -->
        <p>Segundo capÃ­tulo da sÃ©rie de estudos sobre o livro <a href="https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf">Entendendo Algoritmos</a> de Aditya Y.&nbsp;Bhargava.</p>
<ul>
<li><a href="/2025/08/12/busca-binaria-e-introducao-a-analise-de-algoritmos/">CapÃ­tulo 1 - IntroduÃ§Ã£o e Busca&nbsp;BinÃ¡ria</a></li>
<li><a href="/2025/08/27/ordenacao-por-selecao-arrays-e-listas/">CapÃ­tulo 2 - Arrays, Listas e OrdenaÃ§Ã£o por SeleÃ§Ã£o</a> -ğŸ“ <strong>vocÃª estÃ¡&nbsp;aqui</strong></li>
<li><a href="/2025/09/17/recursao/">CapÃ­tulo 3 -&nbsp;RecursÃ£o</a></li>
</ul>
<p>Espero que vocÃªs tenham gostado da forma como estruturei o <a href="/2025/08/12/busca-binaria-e-introducao-a-analise-de-algoritmos/">primeiro capÃ­tulo</a>, seguirei naquela mesma linha de raciocÃ­nio e explicaÃ§Ã£o. Se vocÃª tiver alguma sugestÃ£o de exercÃ­cio ou melhoria na explicaÃ§Ã£o, me conta aqui que eu ficarei feliz em receber esse feedback&nbsp;ğŸ«‚ğŸ’•</p>
<hr>
<p>No capÃ­tulo 2, o autor aprofunda dois conceitos fundamentais: <strong>estruturas de dados</strong> (como arrays e listas) e a <strong>eficiÃªncia dos algoritmos</strong> (notaÃ§Ã£o Big O). Para ilustrar isso, ele apresenta o algoritmo de <strong>ordenaÃ§Ã£o por seleÃ§Ã£o</strong>.</p>
<h1>Arrays e&nbsp;Listas</h1>
<p>Antes de falar em ordenaÃ§Ã£o, Ã© importante entender como os dados podem ser armazenados na memÃ³ria.&nbsp;ğŸ‘€</p>
<p>O autor traz uma analogia que faz o entendimento ficar muuuito mais fÃ¡cil. Em resumo, a ideia Ã© algo&nbsp;assim:</p>
<p>Imagine que vocÃª vai a um show e precisa guardar suas coisas na chapelaria (eu nem sabia que isso existia ğŸ¤”). Apenas algumas gavetas estÃ£o disponÃ­veis e vocÃª pode guardar um item por gaveta. VocÃª pega e guarda suas coisas nessas gavetas, fecha, e estÃ¡ pronto para ir ao&nbsp;show.</p>
<p>A memÃ³ria do computador funciona mais ou menos assim. O computador parece um grande conjunto de gavetas, e cada gaveta tem um endereÃ§o. Cada vez que tu armazena um item na memÃ³ria, o computador fornece um endereÃ§o para guardar esse&nbsp;item.</p>
<p>E aÃ­, se tu quiser armazenar mÃºltiplos itens, existem duas maneiras principais de fazer isso: <strong>arrays</strong> e <strong>listas</strong>.</p>
<hr>
<h2>Arrays</h2>
<ul>
<li>SÃ£o blocos contÃ­guos de memÃ³ria (um ao lado do&nbsp;outro).</li>
<li>Cada elemento pode ser acessado <strong>diretamente</strong> pelo Ã­ndice, permitindo uma leitura rÃ¡pida.<ul>
<li>Isso significa que a operaÃ§Ã£o de busca por posiÃ§Ã£o Ã© O(1), ou seja,&nbsp;constante.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># acesso direto ao 20</span>
</code></pre></div>

<ul>
<li>O lado ruim do array Ã© que, se tu quiser adicionar mais um item e a gaveta seguinte estiver ocupada, serÃ¡ necessÃ¡rio solicitar ao computador uma Ã¡rea de memÃ³ria maior para armazenar todos os itens e mover os existentes para&nbsp;lÃ¡.</li>
<li>EntÃ£o adicionar novos itens a um array Ã© algo que pode ser muito&nbsp;lento.</li>
<li>Deletar um elemento Ã© tÃ£o custoso quanto adicionar, todos os elementos seguintes precisam ser&nbsp;movidos.</li>
</ul>
<hr>
<h2>Listas&nbsp;encadeadas</h2>
<ul>
<li>Seus itens podem estar <strong>em qualquer lugar da memÃ³ria</strong>.</li>
<li>Cada item armazena o endereÃ§o do prÃ³ximo item da&nbsp;lista.</li>
<li>Semelhante a uma caÃ§a ao tesouro, cada pista encontrada indica onde estÃ¡ a prÃ³xima&nbsp;etapa.</li>
<li>Adicionar um item Ã© simples, vocÃª coloca o item em qualquer lugar da memÃ³ria e atualiza o endereÃ§o do item&nbsp;anterior.</li>
<li>Para deletar, Ã© tÃ£o simples quanto, basta alterar o endereÃ§o do item anterior para apontar para o prÃ³ximo&nbsp;item.</li>
<li>O lado ruim da lista encadeada Ã© que, para acessar um elemento especÃ­fico (por exemplo, o Ãºltimo), vocÃª nÃ£o pode ir direto, precisa percorrer a lista <strong>item por item</strong> atÃ© chegar&nbsp;lÃ¡.</li>
</ul>
<div class="highlight"><pre><span></span><code>  <span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
      <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">valor</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">valor</span> <span class="o">=</span> <span class="n">valor</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">proximo</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
  <span class="n">a</span><span class="o">.</span><span class="n">proximo</span> <span class="o">=</span> <span class="n">b</span>

  <span class="c1"># Percorrendo</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">a</span>
  <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">valor</span><span class="p">)</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">proximo</span>
</code></pre></div>

<p>Explicando o cÃ³digo acima:
1. Crio a&nbsp;classe <code>Node</code>, que armazena um valor&nbsp;(<code>valor</code>) e um ponteiro para o prÃ³ximo nÃ³&nbsp;(<code>proximo</code>).
2. Crio dois&nbsp;nÃ³s: <code>a</code> com valor 10&nbsp;e <code>b</code> com valor 20.
3.&nbsp;Ligo <code>a</code> ao <code>b</code> com <code>a.proximo = b</code>.
4. Percorro a lista&nbsp;com <code>while n:</code> imprimindo <code>n.valor</code> atÃ© chegar no final&nbsp;(<code>None</code>).</p>
<p>A saÃ­da pra esse&nbsp;cÃ³digo:</p>
<div class="highlight"><pre><span></span><code><span class="mi">10</span>
<span class="mi">20</span>
</code></pre></div>

<hr>
<p>NÃ£o sei vocÃªs, mas <strong>entender a diferenÃ§a entre arrays e listas</strong> foi um verdadeiro estalo para mim. Como aprendi Python primeiro, eu meio que usava essas estruturas no automÃ¡ticoâ€¦ ğŸ¥² 
Pode parecer algo Ã³bvio ou atÃ© desnecessÃ¡rio, afinal, lidamos com arrays e listas o tempo todo, mas foi incrÃ­vel compreender <strong>por que as coisas funcionam do jeito que funcionam</strong>. Minha cabeÃ§a finalmente comeÃ§ou a encaixar as peÃ§as e perceber a lÃ³gica por trÃ¡s das operaÃ§Ãµes. Fiquei meio&nbsp;que:</p>
<p><img src="/images/cat-in-shock-surprises.gif" alt="gato surpreso" width="150"/></p>
<p>Aqui estÃ£o os tempos de execuÃ§Ã£o para as operaÃ§Ãµes mais comuns em arrays e listas&nbsp;encadeadas</p>
<p><img src="/images/array_lista.png" alt="tempo de execuÃ§Ã£o" width="400"/></p>
<p>Acho importante trazer essa tabela, para que o entendimento sobre notaÃ§Ã£o Big O se consolide e pra todos entenderem o impacto das nossas escolhas em diferentes&nbsp;situaÃ§Ãµes.</p>
<p>A interpretaÃ§Ã£o pra essa tabela de uma forma mais explÃ­cita&nbsp;seria:</p>
<ul>
<li>
<p><strong>Leitura</strong>:</p>
<ul>
<li>
<p><strong>Array â†’ O(1)</strong>:
    Em um array, cada posiÃ§Ã£o tem um endereÃ§o fixo na memÃ³ria. EntÃ£o, se vocÃª quiser o 5Âº elemento, o computador vai direto nele de uma forma super rÃ¡pida e em tempo&nbsp;constante.</p>
</li>
<li>
<p><strong>Lista â†’ O(n)</strong>:
    uma lista encadeada, cada elemento sabe apenas quem Ã© o prÃ³ximo. EntÃ£o, para achar o 5Âº elemento, vocÃª precisa comeÃ§ar do 1Âº, depois o 2Âº, depois o 3Âºâ€¦ atÃ© chegar no 5Âº. Quanto maior a lista, mais tempo&nbsp;demora.</p>
</li>
</ul>
</li>
<li>
<p><strong>InserÃ§Ã£o</strong>:</p>
<ul>
<li>
<p><strong>Array â†’ O(n)</strong>:
    Se o array estiver cheio e vocÃª quiser enfiar um novo item no meio, tem que â€œempurrarâ€ todos os outros elementos uma posiÃ§Ã£o para frente. Isso pode levar bastante&nbsp;tempo.</p>
</li>
<li>
<p><strong>Lista â†’ O(1)</strong>:
    Se vocÃª jÃ¡ sabe a posiÃ§Ã£o, inserir numa lista Ã© rapidinho, basta mudar quem aponta pra quem e&nbsp;pronto.</p>
</li>
</ul>
</li>
<li>
<p><strong>DeleÃ§Ã£o</strong>:</p>
<ul>
<li>
<p><strong>Array â†’ O(n)</strong>:
    Se vocÃª remove um item no meio do array, precisa â€œpuxarâ€ todos os elementos da frente uma posiÃ§Ã£o pra trÃ¡s para fechar o&nbsp;buraco.</p>
</li>
<li>
<p><strong>Lista â†’ O(1)</strong>:
    Assim como na inserÃ§Ã£o, basta mudar os ponteiros para pular o item que vocÃª quer remover. NÃ£o mexe em mais&nbsp;ninguÃ©m.</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1>OrdenaÃ§Ã£o por&nbsp;seleÃ§Ã£o</h1>
<p>O autor apresenta o algoritmo Selection Sort, que Ã© simples de implementar, mas nÃ£o muito eficiente.
A diferenÃ§a entre arrays e listas em Python torna importante entender como o algoritmo percorre e manipula os&nbsp;elementos.</p>
<h3>Ideia do&nbsp;algoritmo</h3>
<ol>
<li>Encontrar o menor elemento da&nbsp;lista</li>
<li>ColocÃ¡-lo na primeira&nbsp;posiÃ§Ã£o</li>
<li>Repetir para as posiÃ§Ãµes seguintes atÃ© ordenar toda a&nbsp;lista</li>
</ol>
<h4>ImplementaÃ§Ã£o em&nbsp;Python:</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">busca_menor</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encontra o Ã­ndice do menor elemento em um array.</span>

<span class="sd">    ParÃ¢metros:</span>
<span class="sd">    arr (list): Lista de elementos comparÃ¡veis.</span>

<span class="sd">    Retorna:</span>
<span class="sd">    int: Ãndice do menor elemento encontrado.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">menor</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">menor_indice</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">menor</span><span class="p">:</span>
            <span class="n">menor</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">menor_indice</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">menor_indice</span>

<span class="k">def</span> <span class="nf">ordenacao_por_selecao</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ordena uma lista usando o algoritmo de ordenaÃ§Ã£o por seleÃ§Ã£o.</span>

<span class="sd">    A funÃ§Ã£o cria uma nova lista, removendo o menor elemento</span>
<span class="sd">    da lista original a cada iteraÃ§Ã£o e adicionando-o Ã  lista ordenada.</span>

<span class="sd">    ParÃ¢metros:</span>
<span class="sd">    arr (list): Lista de nÃºmeros a serem ordenados.</span>

<span class="sd">    Retorna:</span>
<span class="sd">    list: Nova lista ordenada em ordem crescente.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">novo_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">menor</span> <span class="o">=</span> <span class="n">busca_menor</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">novo_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">menor</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">novo_arr</span>

<span class="nb">print</span><span class="p">(</span><span class="n">ordenacao_por_selecao</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">]))</span> <span class="c1"># SaÃ­da: [2, 3, 5, 6, 10]</span>
</code></pre></div>

<hr>
<h3>Complexidade e Big&nbsp;O</h3>
<ul>
<li>O selection sort precisa percorrer todos os elementos vÃ¡rias&nbsp;vezes.</li>
<li>Para n elementos, ele faz aproximadamente n Ã— n&nbsp;operaÃ§Ãµes.</li>
<li>Isso significa que seu desempenho Ã©&nbsp;O(nÂ²).</li>
</ul>
<p>Este Ã© um exemplo clÃ¡ssico que mostra como <strong>algoritmos diferentes podem resolver o mesmo problema com eficiÃªncias diferentes</strong>, destacando a importÃ¢ncia de escolher o algoritmo certo dependendo do tamanho e da estrutura dos&nbsp;dados.</p>
<hr>
<h2>Curiosidades</h2>
<ul>
<li>As listas em Python sÃ£o, na verdade, <strong>arrays</strong>.</li>
<li>O&nbsp;mÃ©todo <code>append</code> (adicionar no final) Ã© considerado de complexidade <strong>O(1)</strong> na mÃ©dia. Isso porque adicionar um item no final geralmente Ã© bem barato: sÃ³ colocar no prÃ³ximo espaÃ§o&nbsp;livre.</li>
<li>O â€œcusto altoâ€ aparece em operaÃ§Ãµes&nbsp;como <code>insert</code> ou <code>remove</code> no meio da lista. AÃ­ Ã© preciso deslocar todos os elementos seguintes, o que pode ser <strong>O(n)</strong>.</li>
<li>Uma forma de visualizar: pense numa pilha de pratos. Colocar ou tirar um prato do topo&nbsp;(como <code>append</code> e <code>pop</code>) Ã© fÃ¡cil. Mas se vocÃª quiser enfiar ou tirar um prato do meio da pilha&nbsp;(<code>insert</code> ou <code>remove</code>), vai ter que mover todos os pratos que estavam em cima&nbsp;primeiro.</li>
</ul>
<hr>
<h2>ExercÃ­cios recomendados&nbsp;ğŸ‘©ğŸ»â€ğŸ’»ğŸ’</h2>
<p>Para reforÃ§ar o aprendizado, aqui vÃ£o alguns desafios&nbsp;prÃ¡ticos:</p>
<p><strong>LeetCode</strong></p>
<ul>
<li>
<p><a href="https://leetcode.com/problems/two-sum/description/">Two Sum</a> - clÃ¡ssico de&nbsp;arrays</p>
</li>
<li>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Best Time to Buy and Sell Stock</a> - Percorrer array com anÃ¡lise de&nbsp;tempo</p>
</li>
<li>
<p><a href="https://leetcode.com/problems/merge-sorted-array/description/">Merge Sorted Array</a> - ManipulaÃ§Ã£o de listas&nbsp;ordenadas</p>
</li>
</ul>
<p><strong>Exercism</strong></p>
<ul>
<li><a href="https://exercism.org/tracks/python/exercises/isogram">Isogram</a> - Percorre strings/arrays verificando&nbsp;duplicatas</li>
</ul>
<hr>
<p>E assim, fechamos o segundo capÃ­tulo!
Espero que tenha sido Ãºtil e leve de ler&nbsp;ğŸ’ğŸ»â€â™€ï¸âœ¨</p>

         <!-- BotÃµes de compartilhamento -->
        <div class="compartilhar" style="margin-top: 2em; display: flex; gap: 1em; align-items: center;">
          <strong>Compartilhar:</strong>

          <!-- LinkedIn -->
          <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://anapaula.org/2025/08/27/ordenacao-por-selecao-arrays-e-listas/"
            target="_blank" rel="noopener noreferrer" title="Compartilhar no LinkedIn">
            <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/linkedin.svg" alt="LinkedIn" width="24" height="24" style="vertical-align: middle;">
          </a>

          <!-- Telegram -->
          <a href="https://t.me/share/url?url=https://anapaula.org/2025/08/27/ordenacao-por-selecao-arrays-e-listas/"
             target="_blank" rel="noopener noreferrer" title="Compartilhar no Telegram">
            <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/telegram.svg" alt="Telegram" width="24" height="24" style="vertical-align: middle;">
          </a>

          <!-- WhatsApp -->
          <a href="https://wa.me/?text=https://anapaula.org/2025/08/27/ordenacao-por-selecao-arrays-e-listas/"
            target="_blank" rel="noopener noreferrer" title="Compartilhar no WhatsApp">
            <img src="https://cdn.jsdelivr.net/gh/simple-icons/simple-icons/icons/whatsapp.svg" alt="WhatsApp" width="24" height="24">
          </a>
        </div>
      </div><!-- /.entry-content -->
    </article>
  </section>

  <div id="comments" style="max-width: 700px;">
    <script src="https://utteranc.es/client.js"
      repo="aninhasalesp/meublog"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </div>
</div>

        <footer id="footer" class="body">
                <p>Feito com amor, por <a href="https://github.com/aninhasalesp"> Ana Paula</a> â¤ï¸</p>
        </footer><!-- /#footer -->

</body>
</html>