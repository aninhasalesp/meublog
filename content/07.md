Title: Explorando o livro "Entendendo Algoritmos", cap.3
Date: 2025-09-17
Category: Entendendo algoritmos
Summary: An√°lises e exerc√≠cios pr√°ticos sobre o Cap√≠tulo 3 do livro "Entendendo Algoritmos", com sugest√µes de desafios.
Tags: recurs√£o, pilha

Terceiro cap√≠tulo da s√©rie de estudos sobre o livro [Entendendo Algoritmos](https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf) de Aditya Y. Bhargava.

Se voc√™ est√° acompanhando a s√©rie, j√° resumi os cap√≠tulos anteriores üëÄ, ent√£o volta l√° se tu tiver alguma d√∫vida:  
- [Cap√≠tulo 1 - Introdu√ß√£o a algoritmos](https://anapaula.org/2025/08/12/explorando-o-livro-entendendo-algoritmos-cap1/)  
- [Cap√≠tulo 2 - Ordena√ß√£o por sele√ß√£o](https://anapaula.org/2025/08/27/explorando-o-livro-entendendo-algoritmos-cap2/)

---

Oi, pessoal! Mais um resuminho do nosso livro querido üòä 

Esse cap√≠tulo foi um dos que mais me tirou a sensa√ß√£o de que programa√ß√£o √© m√°gica. Bora entender recurs√£o e pilhas sem medo?

Neste cap√≠tulo, o autor explica de forma simples o conceito e o uso da **recurs√£o**, dividindo a explica√ß√£o em caso base e caso recursivo. 
Ele sugere que voc√™, ao menos uma vez, analise uma fun√ß√£o recursiva com papel e caneta, acompanhando passo a passo, assim voc√™ entender√° como a fun√ß√£o funciona.

# Recurs√£o

√â a t√©cnica onde uma fun√ß√£o chama a si mesma para resolver um problema, dividindo-o em problemas menores. Devido ao fato de uma fun√ß√£o recursiva chamar a si mesma, √© mais f√°cil de escrev√™-la de forma errada e acabar em um loop infinito. Para que a recurs√£o funcione corretamente, ela deve conter um caso base para parar as chamadas e um caso recursivo que aproxime o problema da solu√ß√£o final. 

## Como a recurs√£o funciona:

Antes de mostrar um exemplo de recurs√£o, vamos entender como ela funciona.

1. **Caso base**: define quando a fun√ß√£o deve **parar** de se chamar. Sem ele, a recurs√£o continuaria indefinidamente, causando erro.

2. **Caso recursivo**: √© a parte em que a fun√ß√£o **se chama novamente**, aproximando-se da solu√ß√£o final a cada passo.

Um exemplo cl√°ssico √© o c√°lculo do fatorial de um n√∫mero::

```py
def fatorial(n):
    if n == 0 or n == 1:  # Caso Base
        return 1
    else:  # Caso Recursivo
        return n * fatorial(n - 1)

print(fatorial(5))  # Sa√≠da: 120
```
Nesse exemplo:

- **Caso Base**: `n` √© 0 ou 1, o fatorial √© 1
- **Caso Recursivo**: Se `n` √© maior que 1, o fatorial √© `n * fatorial(n-1)`

Olha como fica quase po√©tico, cada n√∫mero chama o pr√≥ximo at√© o 1 dizer "chega, agora volta". A√≠ a multiplica√ß√£o acontece no caminho de volta.

---

# Pilha

Suponha que voc√™ esteja fazendo um churrasco para os seus amigos. Voc√™ tem uma lista de afazeres em forma de uma pilha de notas adesivas. Quando voc√™ insere um item, ele √© colocado no topo da pilha. Quando voc√™ l√™ um item, l√™ apenas o item do topo da pilha e ele √© retirado da lista. Logo, sua lista de afazeres cont√©m apenas duas a√ß√µes: *push* (inserir) e *pop* (remover e ler).

<img src="{static}/images/pilha.png" alt="pilha" width="700"/>

Esta estrutura de dados √© chamada de pilha. A pilha √© uma estrutura de dados simples e n√≥s usamos o tempo todo sem perceber.

---

# Pilha de chamadas

Sempre que uma fun√ß√£o √© chamada, o computador precisa ‚Äúlembrar‚Äù de onde ela parou para poder continuar depois.
Essa mem√≥ria tempor√°ria √© organizada numa **pilha de chamadas** (call stack).

Funciona assim:

- A cada nova chamada de fun√ß√£o, o computador empilha informa√ß√µes sobre essa execu√ß√£o (como par√¢metros e vari√°veis locais).
- Quando a fun√ß√£o termina, o computador desempilha esses dados e volta para o ponto anterior.

A met√°fora do livro √© √≥tima, pense em uma pilha de pratos na cozinha. Voc√™ s√≥ consegue pegar (ou retirar) o prato que est√° por cima.  Assim tamb√©m funciona com fun√ß√µes, o √∫ltimo que entrou √© o primeiro que sai (LIFO: Last In, First Out).

Podemos visualizar isso com um exemplo simples em Python:

```py

def cumprimenta(nome):
    print("Oi,", nome)
    despedida()

def despedida():
    print("Tchau!")

cumprimenta("Ana")

```
Ordem de execu√ß√£o na pilha:

1. cumprimenta("Ana") √© chamada ‚Üí vai para a pilha.
2. Dentro dela, despedida() √© chamada ‚Üí fica no topo.
3. despedida() roda e sai da pilha.
4. cumprimenta("Ana") roda at√© o fim e sai da pilha.

Ou seja, tudo organizado, prato por prato.

Esse exemplo j√° mostra que n√£o √© s√≥ recurs√£o que usa pilha, mas qualquer fun√ß√£o. A diferen√ßa √© que a recurs√£o for√ßa a pilha a crescer muito mais r√°pido.

---

# Pilha de chamadas com recurs√£o

Com recurs√£o, essa pilha pode crescer bastante, porque a fun√ß√£o vai se chamando v√°rias vezes at√© chegar no caso base.

Exemplo simplificado com `fatorial(3)`:

```
O programa chama fatorial(3)
    - empilha fatorial(3)

Para resolver, precisa de fatorial(2)
    - empilha fatorial(2)

Para resolver, precisa de fatorial(1)
    - empilha fatorial(1)

fatorial(1) chega no caso base e retorna 1
    - desempilha fatorial(1)

Agora fatorial(2) consegue calcular 2 √ó 1 = 2
    - desempilha fatorial(2)

Por fim, fatorial(3) calcula 3 √ó 2 = 6
    - desempilha fatorial(3)
```

No fim, cada chamada s√≥ consegue terminar depois que a chamada menor retorna. 
√â por isso que **definir bem o caso base √© t√£o importante**, sem ele, a fun√ß√£o nunca para de empilhar chamadas e acaba estourando a mem√≥ria (stack overflow).

<img src="{static}/images/coffee.gif" alt="overflow" width="400"/>


Esse ‚Äúestouro da pilha‚Äù √© justamente de onde veio o nome do site [Stack Overflow](https://stackoverflow.com/questions).

Quando vi esse processo pela primeira vez, parecia uma esp√©cie de ‚Äúm√°gica‚Äù, como se o computador simplesmente soubesse de onde voltar.

Foi nesse momento que percebi que entender programa√ß√£o √© muito sobre desmistificar. N√£o √© dom, n√£o √© g√™nio, √© s√≥ empilhar e desempilhar com calma. 
Hoje, sempre que vejo um c√≥digo recursivo, tento imaginar essa pilha acontecendo em segundo plano, isso traz clareza e ainda transforma o ‚Äúeu n√£o nasci pra isso/nunca vou entender isso‚Äù para um ‚Äúhihi que legal‚Äù üòé

<img src="{static}/images/chihuahua.gif" alt="cachorro" width="200"/>

Ent√£o, da pr√≥xima vez que voc√™ se perder num c√≥digo recursivo, respira: desenha a pilha, segue os passos, e lembra que n√£o √© m√°gica, √© s√≥ **pr√°tica**!!!

---

## Curiosidades üí°

1. Uma recurs√£o muito comum fora da programa√ß√£o: bonecas russas (matryoshkas). Cada boneca guarda outra dentro, at√© que a √∫ltima (caso base) n√£o guarda mais nenhuma.
2. Algumas linguagens aplicam otimiza√ß√£o de recurs√£o de cauda (tail call optimization), que reaproveita os quadros da pilha para n√£o estourar a mem√≥ria em fun√ß√µes recursivas muito profundas. Python, por√©m, n√£o faz isso.
3. A pilha de chamadas √© invis√≠vel na maior parte do tempo, mas voc√™ j√° viu ela funcionando, quando o Python mostra um traceback (aquele erro cheio de setas, indicando em que fun√ß√£o a execu√ß√£o estava).
4. Muitas fun√ß√µes recursivas podem ser reescritas de forma iterativa (usando la√ßos `for` ou `while`). Isso evita o risco de estouro da pilha em casos de chamadas muito profundas.
5. Para entender recurs√£o, voc√™ precisa primeiro entender recurs√£o. üòÖ
---

## Exerc√≠cios recomendados üë©üèª‚Äçüíªüíû
Para refor√ßar o aprendizado, aqui v√£o alguns desafios pr√°ticos:

**LeetCode**

- [Merge two sorted lists](https://leetcode.com/problems/merge-two-sorted-lists/description/) - D√° pra resolver recursivamente, tratando como o caso base quando uma lista chega ao fim.
- [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/) - Um problema cl√°ssico de recurs√£o + otimiza√ß√£o (parecido com Fibonacci).

**Exercism**

- [Flatten Array](https://exercism.org/tracks/python/exercises/flatten-array) - Recebe uma lista que pode conter sublistas e precisa retornar tudo ‚Äúachatado‚Äù em uma √∫nica lista
- [Recurs√£o com Python](https://exercism.org/tracks/python/concepts/recursion) - Refor√ßa o conceito de recurs√£o e tem o exerc√≠cio ‚ÄúLuhn‚Äù que admite uma abordagem recursiva

**Desafio extra**

- Crie uma fun√ß√£o recursiva que percorre pastas e arquivos no seu computador (ou s√≥ numa lista aninhada simulada). Isso √© literalmente como muitos sistemas de arquivos funcionam.

--- 
Espero que tenha aproveitado o conte√∫do! ‚ú®üíï

Se tiver alguma sugest√£o de exerc√≠cio ou melhoria na explica√ß√£o, me conta aqui ü´Çüåª