Title: Busca Bin√°ria e Introdu√ß√£o √† An√°lise de Algoritmos
Date: 2025-08-12
Category: Entendendo algoritmos
Summary: Resumo do **cap√≠tulo 1** do livro "Entendendo Algoritmos". Apresenta a busca bin√°ria como exemplo inicial e introduz o conceito de efici√™ncia dos algoritmos, explicando a nota√ß√£o Big O de forma simples.

In√≠cio de uma s√©rie de estudos sobre o livro [Entendendo Algoritmos](https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf) de Aditya Y. Bhargava. 

- [Cap√≠tulo 1 - Introdu√ß√£o e Busca Bin√°ria](/2025/08/12/busca-binaria-e-introducao-a-analise-de-algoritmos/) -üìç **voc√™ est√° aqui**
- [Cap√≠tulo 2 - Arrays, Listas e Ordena√ß√£o por Sele√ß√£o](/2025/08/27/ordenacao-por-selecao-arrays-e-listas/)
- [Cap√≠tulo 3 - Recurs√£o](/2025/09/17/recursao/)

Esse livro foi indicado por uma amiga, [Ana Paula Mendes](https://github.com/anapaulamendes), e eu n√£o imaginava o quanto iria gostar. A leitura √© leve, clara e muito acess√≠vel. Se voc√™, como eu, tem dificuldade em manter a const√¢ncia em leituras t√©cnicas, esse livro √© um achado, f√°cil de entender, √≥timo para aprender ou revisar conceitos. 

Ele apresenta ideias da ci√™ncia da computa√ß√£o que est√£o no nosso dia a dia, muitas vezes sem que a gente perceba.

<img src="{static}/images/livro1.jpg" alt="capa do livro" width="400"/>


Uma das coisas que mais me chamam aten√ß√£o nesse livro √© o jeito como o autor ensina, sempre com exemplos. Em vez de encher de s√≠mbolos e f√≥rmulas, ele quer que a gente visualize os conceitos. Ele acredita, e eu concordo, que aprendemos melhor quando conseguimos relacionar o conte√∫do com algo que j√° conhecemos. E, pra isso, os exemplos ajudam muito. 

E o melhor √© que ele desenha ü§©! 
Sabe aquela frase ‚Äúquer que eu desenhe pra voc√™ entender‚Äù? Eu respondo ‚Äúsim, por favorrrrr!‚Äù e ele realmente desenha. √â maravilhoso ‚ú®. 

D√° pra sentir que tudo foi pensado com cuidado, desde o conte√∫do, os exemplos ilustrados at√© a recapitula√ß√£o no fim de cada cap√≠tulo. 

Depois dessa introdu√ß√£o, bora ver o que o cap√≠tulo 1 ensina.

<img src="{static}/images/hahahaha-gif.gif" alt="gif" width="100"/>

---

# A busca bin√°ria em resumo

Pensa numa lista telef√¥nica com **1 milh√£o de nomes**. Olhar folha por folha seria um pesadelo, n√©? 
Agora, e se eu te dissesse que d√° para encontrar qualquer nome em no **m√°ximo 20 tentativas**? üëÄ

O truque √© simples: a cada etapa, tu elimina metade das op√ß√µes. Comece considerando o elemento que est√° bem no meio da sequ√™ncia. Em uma lista telef√¥nica, isso seria abrir o livro bem no meio. Em uma lista com 10 itens, isso seria pegar o 5o item. Agora compare esse item do meio com o que voc√™ est√° buscando: se eles forem iguais, parab√©ns, voc√™ encontrou o que procurava! Agora, se o item que voc√™ encontrou for MAIOR que o item que voc√™ procura (no caso de nomes em uma lista telef√¥nica, pense em qual nome vem primeiro na ordem alfab√©tica), quer dizer que o item buscado est√° na primeira metade da lista. Caso contr√°rio, o item est√° na segunda metade da lista. E assim voc√™ consegue cortar a lista pela *metade* apenas comparando o item procurado com o item do meio. Depois disso, basta pegar a parte que voc√™ selecionou e aplicar a mesma estrat√©gia, checando o item do meio e descartando metade da lista.
**Observa√ß√£o**: Essa t√©cnica s√≥ funciona se a lista de itens estiver ordenada!

E o mais legal √© que, mesmo que a lista dobre de tamanho, tu s√≥ precisa de **mais uma** etapa para chegar ao resultado. ü§ì

**Exemplo**:
Para facilitar a conta, vamos pegar uma lista menor de 128 nomes e calcular o n√∫mero m√°ximo de etapas que levar√≠amos para encontrar um nome espec√≠fico. Logo em seguida, dobramos o tamanho da lista e vemos que isso adiciona apenas mais uma etapa:

```python
def max_etapas(n):
    etapas = 0
    while n > 1:
        n //= 2
        etapas += 1
    return etapas

print(max_etapas(128)) # 7
print(max_etapas(128*2)) # 8

```

**Observa√ß√£o importante**: numa lista telef√¥nica f√≠sica, a gente j√° sabe pular quase direto para a letra certa, o que lembra mais o funcionamento de um hashmap (ou dict no Python), que encontra um item em tempo constante. Mas no computador, quando temos apenas uma lista ordenada (como `[1, 3, 5, 7, 9, 11, 13]`), n√£o existe esse ‚Äúpulo m√°gico‚Äù, √© a√≠ que a busca bin√°ria pode ajudar, cortando a lista ao meio de forma sistem√°tica at√© encontrar (ou concluir que o elemento n√£o est√° l√°).

Legal n√©? Isso √© ci√™ncia da computa√ß√£o!! üíÅ‚Äç‚ôÄÔ∏è‚ú®

---
## Exemplos b√°sicos de busca bin√°ria:

Pense em um n√∫mero entre 1 e 100. D√° para adivinhar em, no m√°ximo, 7 tentativas:

Minha primeira pergunta: "√â 50?"

- Se voc√™ disser "maior", eu sei que est√° entre 51 e 100
- Se disser "menor", est√° entre 1 e 49

Segunda pergunta: Digamos que seja maior que 50. "√â 75?" (meio entre 51 e 100)

- Maior? Est√° entre 76 e 100
- Menor? Est√° entre 51 e 74

E assim por diante, sempre eliminando metade das possibilidades.

### Vamos ver como fica com uma quantidade maior de n√∫meros:

| Itens na lista | Busca linear (tentativas) | Busca bin√°ria (tentativas) |
| --- | --- | --- |
| 1.000 | at√© 1.000 | at√© 10 |
| 1.000.000 | at√© 1.000.000 | at√© 20 |

Sim, 20 tentativas para encontrar algo entre 1 milh√£o de op√ß√µes! üöÄ

Esse ‚Äúmilagre‚Äù da busca bin√°ria acontece por causa de um conceito chamado **logaritmo**, e j√° j√° eu te mostro o porqu√™.

---

Agora que voc√™ j√° entendeu a busca bin√°ria, vamos entrar em mais tr√™s pontos que andam de m√£os dadas: **logaritmos, tempo de execu√ß√£o e nota√ß√£o Big O**.

Preparei um resumo r√°pido de cada um, do jeito que fez sentido pra mim.
Se em algum momento ficar confuso, n√£o tem problema, d√° uma olhada no livro que √© sucesso ü´Çüíñ

---

## Logaritmos:

O n√∫mero m√°ximo de tentativas na busca bin√°ria √© dado por log‚ÇÇ(n), logaritmo na base 2 de n.

Se o nome assusta, pensa assim:

> **log‚ÇÇ(n) √© o n√∫mero de vezes que voc√™ precisa dividir n por 2 at√© chegar em 1**

**Exemplo**:

- log‚ÇÇ(128) = 7, 7 cortes ao meio at√© sobrar 1 item
- log‚ÇÇ(256) = 8, s√≥ mais uma etapa, mesmo dobrando o tamanho da lista

A base "2" vem justamente porque a cada passo cortamos a lista **pela metade**.

---

## Tempo de execu√ß√£o: 

Sempre que falamos sobre um algoritmo, √© importante pensar no tempo de execu√ß√£o, quanto esfor√ßo (ou quantos passos) ele precisa para chegar ao resultado.

Na **busca linear** (a pesquisa simples), verificamos item por item:

- Lista com 100 n√∫meros ‚Üí at√© 100 tentativas
- Lista com 4 bilh√µes de n√∫meros ‚Üí at√© 4 bilh√µes de tentativas


O tempo de execu√ß√£o cresce na mesma propor√ß√£o que o tamanho da lista. Chamamos isso de **tempo linear**.

A **busca bin√°ria** √© um outro mundo:

- Lista com 100 n√∫meros ‚Üí no m√°ximo 7 tentativas
- Lista com 4 bilh√µes ‚Üí no m√°ximo 32 tentativas

Isso acontece porque a busca bin√°ria corta as possibilidades pela metade a cada passo. Esse tipo de crescimento √© chamado de **tempo logar√≠tmico**.

<img src="{static}/images/image-4.png" alt="tempo de execu√ß√£o" width="400"/>

---
## Nota√ß√£o Big O

A **nota√ß√£o Big O** √© um jeito de medir a efici√™ncia de um algoritmo, mostrando como o **tempo de execu√ß√£o** cresce conforme aumentamos o tamanho da entrada.

- O(log n), tempo logar√≠tmico (ex: pesquisa bin√°ria)
- O(n), tempo linear (ex: pesquisa simples)
- O(n * log n), um algoritmo r√°pido de ordena√ß√£o, como quicksort (Cap√≠tulo 4)
- O(n¬≤), um algoritmo de ordena√ß√£o mais lenta, como ordena√ß√£o por sele√ß√£o (Cap√≠tulo 2).
- O(n!), um algoritmo extremamente lento, como o do caixeiro viajante (Cap√≠tulo 1).

O livro ilustra isso de forma bem visual e intuitiva: cresce linearmente, cresce em log, cresce muito, cresce lento... e por a√≠ vai. 

---

**Agora que vimos como a busca bin√°ria funciona, vale notar que ela n√£o est√° restrita a livros, ela aparece em v√°rias situa√ß√µes do nosso dia a dia**

- **Sistemas de busca (Google, WhatsApp, Spotify)**: por tr√°s, usam varia√ß√µes de busca bin√°ria em listas ordenadas ou √≠ndices.
- **Filtragem de dados**: encontrar rapidamente um registro espec√≠fico em planilhas ou bases de dados grandes.
- **Depura√ß√£o de c√≥digo**: reduzir o espa√ßo do problema pela metade a cada teste para achar onde o bug est√°.

**Observa√ß√£o**: para que a busca bin√°ria funcione, os dados precisam estar ordenados.

## Vamos praticar rapidinho?

Aqui est√° uma lista ordenada de n√∫meros: `[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32]`

Tente encontrar o n√∫mero 22 de duas formas:

1. **Busca linear:** V√° um a um desde o 2.  
2. **Busca bin√°ria:** Comece no meio, elimine metade a cada passo.

Compare quantos passos cada m√©todo precisou

---

## Curiosidades

- O git tem uma funcionalidade chamada [`git bisect`](https://git-scm.com/docs/git-bisect) que usa busca bin√°ria para ajudar desenvolvedores a encontrarem bug
- Se o item que estamos buscando for o primeiro item da lista, esse √© o melhor caso na busca linear e o pior caso na busca bin√°ria
- A implementa√ß√£o do `sortedcontainers` usa busca bin√°ria (a partir do m√≥dulo bisect), [veja aqui](https://grantjenks.com/docs/sortedcontainers/_modules/sortedcontainers/sortedlist.html#SortedList)
 
---

## Exerc√≠cios recomendados üë©üèª‚Äçüíªüíû
Para refor√ßar o aprendizado, aqui v√£o alguns desafios pr√°ticos:

**LeetCode**

- [Binary Search](https://leetcode.com/problems/binary-search/description/) ‚Äî implementa√ß√£o direta.

- [Search Insert Position](https://leetcode.com/problems/search-insert-position/description/) ‚Äî varia√ß√£o para encontrar onde inserir um n√∫mero.

- [First Bad Version](https://leetcode.com/problems/first-bad-version/description/) ‚Äî busca bin√°ria aplicada em API.

**Exercism**

- [Binary Search (Python Track)](https://exercism.org/tracks/python/exercises/binary-search) ‚Äî implementa√ß√£o e testes.


**Dica: resolva primeiro o problema sem olhar a solu√ß√£o e depois compare com implementa√ß√µes otimizadas.**

E assim come√ßa meu roadmap de estudo: cada cap√≠tulo do livro vem acompanhado de exerc√≠cios para fixar o conte√∫do.