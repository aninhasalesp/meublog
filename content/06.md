Title: OrdenaÃ§Ã£o por SeleÃ§Ã£o, Arrays e Listas
Date: 2025-08-27
Category: Entendendo algoritmos
Slug: ordenacao-por-selecao-arrays-e-listas
Summary: Resumo do **capÃ­tulo 2** do livro "Entendendo Algoritmos". Mostra o funcionamento do algoritmo de ordenaÃ§Ã£o por seleÃ§Ã£o e compara arrays e listas em termos de operaÃ§Ãµes e eficiÃªncia, reforÃ§ando o uso da notaÃ§Ã£o Big O.

Segundo capÃ­tulo da sÃ©rie de estudos sobre o livro [Entendendo Algoritmos](https://www.kufunda.net/publicdocs/Entendendo%20Algoritmos%20Um%20guia%20ilustrado%20para%20programadores%20e%20outros%20curiosos%20(Aditya%20Y.%20Bhargava).pdf) de Aditya Y. Bhargava.

- [CapÃ­tulo 1 - IntroduÃ§Ã£o e Busca BinÃ¡ria](/2025/08/12/busca-binaria-e-introducao-a-analise-de-algoritmos/)
- [CapÃ­tulo 2 - Arrays, Listas e OrdenaÃ§Ã£o por SeleÃ§Ã£o](/2025/08/27/ordenacao-por-selecao-arrays-e-listas/) -ğŸ“ **vocÃª estÃ¡ aqui**
- [CapÃ­tulo 3 - RecursÃ£o](/2025/09/17/recursao/)

Espero que vocÃªs tenham gostado da forma como estruturei o [primeiro capÃ­tulo](/2025/08/12/busca-binaria-e-introducao-a-analise-de-algoritmos/), seguirei naquela mesma linha de raciocÃ­nio e explicaÃ§Ã£o. Se vocÃª tiver alguma sugestÃ£o de exercÃ­cio ou melhoria na explicaÃ§Ã£o, me conta aqui que eu ficarei feliz em receber esse feedback ğŸ«‚ğŸ’•

---

No capÃ­tulo 2, o autor aprofunda dois conceitos fundamentais: **estruturas de dados** (como arrays e listas) e a **eficiÃªncia dos algoritmos** (notaÃ§Ã£o Big O). Para ilustrar isso, ele apresenta o algoritmo de **ordenaÃ§Ã£o por seleÃ§Ã£o**.

# Arrays e Listas

Antes de falar em ordenaÃ§Ã£o, Ã© importante entender como os dados podem ser armazenados na memÃ³ria. ğŸ‘€

O autor traz uma analogia que faz o entendimento ficar muuuito mais fÃ¡cil. Em resumo, a ideia Ã© algo assim:

Imagine que vocÃª vai a um show e precisa guardar suas coisas na chapelaria (eu nem sabia que isso existia ğŸ¤”). Apenas algumas gavetas estÃ£o disponÃ­veis e vocÃª pode guardar um item por gaveta. VocÃª pega e guarda suas coisas nessas gavetas, fecha, e estÃ¡ pronto para ir ao show.

A memÃ³ria do computador funciona mais ou menos assim. O computador parece um grande conjunto de gavetas, e cada gaveta tem um endereÃ§o. Cada vez que tu armazena um item na memÃ³ria, o computador fornece um endereÃ§o para guardar esse item.

E aÃ­, se tu quiser armazenar mÃºltiplos itens, existem duas maneiras principais de fazer isso: **arrays** e **listas**.

---

## Arrays

- SÃ£o blocos contÃ­guos de memÃ³ria (um ao lado do outro).
- Cada elemento pode ser acessado **diretamente** pelo Ã­ndice, permitindo uma leitura rÃ¡pida.
    - Isso significa que a operaÃ§Ã£o de busca por posiÃ§Ã£o Ã© O(1), ou seja, constante.

```python
arr = [10, 20, 30]
print(arr[1])  # acesso direto ao 20
```

- O lado ruim do array Ã© que, se tu quiser adicionar mais um item e a gaveta seguinte estiver ocupada, serÃ¡ necessÃ¡rio solicitar ao computador uma Ã¡rea de memÃ³ria maior para armazenar todos os itens e mover os existentes para lÃ¡.
  - EntÃ£o adicionar novos itens a um array Ã© algo que pode ser muito lento.
- Deletar um elemento Ã© tÃ£o custoso quanto adicionar, todos os elementos seguintes precisam ser movidos.

---

## Listas encadeadas

- Seus itens podem estar **em qualquer lugar da memÃ³ria**.
- Cada item armazena o endereÃ§o do prÃ³ximo item da lista.
  - Semelhante a uma caÃ§a ao tesouro, cada pista encontrada indica onde estÃ¡ a prÃ³xima etapa.
- Adicionar um item Ã© simples, vocÃª coloca o item em qualquer lugar da memÃ³ria e atualiza o endereÃ§o do item anterior.
- Para deletar, Ã© tÃ£o simples quanto, basta alterar o endereÃ§o do item anterior para apontar para o prÃ³ximo item.
- O lado ruim da lista encadeada Ã© que, para acessar um elemento especÃ­fico (por exemplo, o Ãºltimo), vocÃª nÃ£o pode ir direto, precisa percorrer a lista **item por item** atÃ© chegar lÃ¡.

```python
  class Node:
      def __init__(self, valor):
          self.valor = valor
          self.proximo = None

  a = Node(10)
  b = Node(20)
  a.proximo = b

  # Percorrendo
  n = a
  while n:
      print(n.valor)
      n = n.proximo
```

Explicando o cÃ³digo acima:
1. Crio a classe `Node`, que armazena um valor (`valor`) e um ponteiro para o prÃ³ximo nÃ³ (`proximo`).
2. Crio dois nÃ³s: `a` com valor 10 e `b` com valor 20.
3. Ligo `a` ao `b` com `a.proximo = b`.
4. Percorro a lista com `while n:` imprimindo `n.valor` atÃ© chegar no final (`None`).

A saÃ­da pra esse cÃ³digo:

```python

10
20
```
---

NÃ£o sei vocÃªs, mas **entender a diferenÃ§a entre arrays e listas** foi um verdadeiro estalo para mim. Como aprendi Python primeiro, eu meio que usava essas estruturas no automÃ¡ticoâ€¦ ğŸ¥² 
Pode parecer algo Ã³bvio ou atÃ© desnecessÃ¡rio, afinal, lidamos com arrays e listas o tempo todo, mas foi incrÃ­vel compreender **por que as coisas funcionam do jeito que funcionam**. Minha cabeÃ§a finalmente comeÃ§ou a encaixar as peÃ§as e perceber a lÃ³gica por trÃ¡s das operaÃ§Ãµes. Fiquei meio que:

<img src="{static}/images/cat-in-shock-surprises.gif" alt="gato surpreso" width="150"/>

Aqui estÃ£o os tempos de execuÃ§Ã£o para as operaÃ§Ãµes mais comuns em arrays e listas encadeadas

<img src="{static}/images/array_lista.png" alt="tempo de execuÃ§Ã£o" width="400"/>

Acho importante trazer essa tabela, para que o entendimento sobre notaÃ§Ã£o Big O se consolide e pra todos entenderem o impacto das nossas escolhas em diferentes situaÃ§Ãµes.

A interpretaÃ§Ã£o pra essa tabela de uma forma mais explÃ­cita seria:

- **Leitura**:
    - **Array â†’ O(1)**:
        Em um array, cada posiÃ§Ã£o tem um endereÃ§o fixo na memÃ³ria. EntÃ£o, se vocÃª quiser o 5Âº elemento, o computador vai direto nele de uma forma super rÃ¡pida e em tempo constante.

    - **Lista â†’ O(n)**:
        uma lista encadeada, cada elemento sabe apenas quem Ã© o prÃ³ximo. EntÃ£o, para achar o 5Âº elemento, vocÃª precisa comeÃ§ar do 1Âº, depois o 2Âº, depois o 3Âºâ€¦ atÃ© chegar no 5Âº. Quanto maior a lista, mais tempo demora.

- **InserÃ§Ã£o**:
    - **Array â†’ O(n)**:
        Se o array estiver cheio e vocÃª quiser enfiar um novo item no meio, tem que â€œempurrarâ€ todos os outros elementos uma posiÃ§Ã£o para frente. Isso pode levar bastante tempo.

    - **Lista â†’ O(1)**:
        Se vocÃª jÃ¡ sabe a posiÃ§Ã£o, inserir numa lista Ã© rapidinho, basta mudar quem aponta pra quem e pronto.

- **DeleÃ§Ã£o**:
    - **Array â†’ O(n)**:
        Se vocÃª remove um item no meio do array, precisa â€œpuxarâ€ todos os elementos da frente uma posiÃ§Ã£o pra trÃ¡s para fechar o buraco.

    - **Lista â†’ O(1)**:
        Assim como na inserÃ§Ã£o, basta mudar os ponteiros para pular o item que vocÃª quer remover. NÃ£o mexe em mais ninguÃ©m.

---

# OrdenaÃ§Ã£o por seleÃ§Ã£o

O autor apresenta o algoritmo Selection Sort, que Ã© simples de implementar, mas nÃ£o muito eficiente.
A diferenÃ§a entre arrays e listas em Python torna importante entender como o algoritmo percorre e manipula os elementos.

### Ideia do algoritmo

1. Encontrar o menor elemento da lista
2. ColocÃ¡-lo na primeira posiÃ§Ã£o
3. Repetir para as posiÃ§Ãµes seguintes atÃ© ordenar toda a lista

#### ImplementaÃ§Ã£o em Python: 

```python

def busca_menor(arr):
    """
    Encontra o Ã­ndice do menor elemento em um array.

    ParÃ¢metros:
    arr (list): Lista de elementos comparÃ¡veis.

    Retorna:
    int: Ãndice do menor elemento encontrado.
    """
    menor = arr[0]
    menor_indice = 0
    for i in range(1, len(arr)):
        if arr[i] < menor:
            menor = arr[i]
            menor_indice = i
    return menor_indice

def ordenacao_por_selecao(arr):
    """
    Ordena uma lista usando o algoritmo de ordenaÃ§Ã£o por seleÃ§Ã£o.

    A funÃ§Ã£o cria uma nova lista, removendo o menor elemento
    da lista original a cada iteraÃ§Ã£o e adicionando-o Ã  lista ordenada.

    ParÃ¢metros:
    arr (list): Lista de nÃºmeros a serem ordenados.

    Retorna:
    list: Nova lista ordenada em ordem crescente.
    """
    novo_arr = []
    for i in range(len(arr)):
        menor = busca_menor(arr)
        novo_arr.append(arr.pop(menor))
    return novo_arr

print(ordenacao_por_selecao([5, 3, 6, 2, 10])) # SaÃ­da: [2, 3, 5, 6, 10]
```

---

### Complexidade e Big O

- O selection sort precisa percorrer todos os elementos vÃ¡rias vezes.
- Para n elementos, ele faz aproximadamente n Ã— n operaÃ§Ãµes.
- Isso significa que seu desempenho Ã© O(nÂ²).

Este Ã© um exemplo clÃ¡ssico que mostra como **algoritmos diferentes podem resolver o mesmo problema com eficiÃªncias diferentes**, destacando a importÃ¢ncia de escolher o algoritmo certo dependendo do tamanho e da estrutura dos dados.

---

## Curiosidades

- As listas em Python sÃ£o, na verdade, **arrays**.
- O mÃ©todo `append` (adicionar no final) Ã© considerado de complexidade **O(1)** na mÃ©dia. Isso porque adicionar um item no final geralmente Ã© bem barato: sÃ³ colocar no prÃ³ximo espaÃ§o livre.
- O â€œcusto altoâ€ aparece em operaÃ§Ãµes como `insert` ou `remove` no meio da lista. AÃ­ Ã© preciso deslocar todos os elementos seguintes, o que pode ser **O(n)**.
- Uma forma de visualizar: pense numa pilha de pratos. Colocar ou tirar um prato do topo (como `append` e `pop`) Ã© fÃ¡cil. Mas se vocÃª quiser enfiar ou tirar um prato do meio da pilha (`insert` ou `remove`), vai ter que mover todos os pratos que estavam em cima primeiro.

---

## ExercÃ­cios recomendados ğŸ‘©ğŸ»â€ğŸ’»ğŸ’
Para reforÃ§ar o aprendizado, aqui vÃ£o alguns desafios prÃ¡ticos:

**LeetCode**

- [Two Sum](https://leetcode.com/problems/two-sum/description/) - clÃ¡ssico de arrays

- [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/) - Percorrer array com anÃ¡lise de tempo

- [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/) - ManipulaÃ§Ã£o de listas ordenadas

**Exercism**

- [Isogram](https://exercism.org/tracks/python/exercises/isogram) - Percorre strings/arrays verificando duplicatas

--- 

E assim, fechamos o segundo capÃ­tulo!
Espero que tenha sido Ãºtil e leve de ler ğŸ’ğŸ»â€â™€ï¸âœ¨